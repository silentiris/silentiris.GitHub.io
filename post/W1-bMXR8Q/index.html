<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="分享代码日常">
<meta name="theme-color" content="#000">
<title>6.11 周报 | silentIris</title>
<link rel="shortcut icon" href="/favicon.ico?v=1697641474560">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






  <meta name="description" content="6.11 周报" />
  <meta name="keywords" content="周报" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>silentIris</span>
            </a>  
          
        </div>
        
          <p class="subtitle">依然自由自我</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-globe"></i> 首页
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/archives" target="_self">
                  <i class="fa fa-globe"></i> 归档
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tags" target="_self">
                  <i class="fa fa-globe"></i> 标签
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/post/jZ3IrV_aj" target="_self">
                  <i class="fa fa-globe"></i> 关于
                </a>
              
            </li>
          
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">silentIris</p>
    
    <div class="site-description right-motion">
      
      
      
        <p>对后端和运维感兴趣</p>
      
        <p>技术栈java/go/python</p>
      
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">25</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">18</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  

  



</div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    jQuery.Velocity(hideElement, 'stop');
    jQuery.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        jQuery.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://silentiris.github.io/post/W1-bMXR8Q/"> 6.11 周报 </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2023-06-12 13:36:48">2023-06-12  Monday</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">标签:</span>
       
      <a href="https://silentiris.github.io/tag/yxHfiDZjK/">
        <span>周报</span>
      </a>
       
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span
        >3<span class="language" data-lan="minute"
          >分钟</span
        ></span
      >
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span
        >843<span class="pc-show language" data-lan="words"
          >字数</span
        ></span
      >
    </span>
    
  </div>
</section>

            <div class="post-body next-md-body" id="post_body">
              <p>这一周大概按照规划所说的主要复习六级和期末，但其实也搞了不少编程的（确实有意思，瘾犯了...</p>
<p>在这一周里其实还是有很大问题，先总结一下干了什么吧：</p>
<ol>
<li>每天一套英语六级。这个确实落实了，每天也都有听力。但其实落实的具体过程很不行。首先是跟高中一样的问题：太浮躁。做完对改完就想干其他事。最后实际上可能只是只是把词给记了记，最多看一下阅读。听力复听只有第一天落实了，而且效果一般。还有一个问题是听力总是不能集中，只有在非常集中的时候才可能能听明白一点，但总是没法一直保持注意力高度集中。最后导致听力非常拉跨。对于阅读来说，除了第一篇，正确率尚可，15选10基本能做到25分钟错1-2个，阅读15分钟1-2个。前面的选词很拉跨，每次基本都错五个，但还不是不能接受，占比低，用时较短。翻译现在用时太长了，很多固定的形式不知道怎么表达，作文还没有联系。总之，还有很多需要提高的。</li>
<li>高数复习。这个得益于老师的良心复习计划和上课带着我们复习，推动的速度还挺快。但有一些记得很不牢靠，需要再做一做题。尤其是级数和微分方程。而且总的来说还是感觉水了点，效率有点低。尤其是对于级数的知识点的复习还有问题。考试前一周还需要再看一看。</li>
<li>大物复习。也就周六周日复习了一下，而且时间很短。总的来说，虽然可以说完成了纸上写的目标，但是只是看了看基础知识点，把最基本的题做了做，还需要再复习一遍，把题再做一遍。目前存在的问题是不知道后面的磁和光要怎么复习了。再看一看同学的笔记之类的把。</li>
<li>nginx配置。这周摸鱼的时候做的。但是其实还用了挺多时间。总的来说，折腾了半天，对nginx搞动静分离和反向代理有了一点认识吧，会一些基本的配置和软连接，对nginx的运作有了一些基本的了解。折腾了半天也勉强会配置一下https。不过最后还是nginx proxy manager了。</li>
<li>每天看十页computer networing.其实有很大一部分时间都用在翻译和理解意思上，但是个人觉得这种方法还是可以的，而且书本身足够通俗易懂。</li>
</ol>
<p>问题：</p>
<ol>
<li>怎么样可以保证一段时间的注意力高度集中。</li>
<li>怎么尽可能的提高阅读速度同时还尽量保证捕获关键信息。</li>
</ol>
<p>下周规划：</p>
<p>总体是复习加代码，现在时间较为宽松，有了更多时间但一定要注意提高效率，有目的一点。</p>
<ol>
<li>高数复习完，复习题写完。</li>
<li>英语5套六级题，保证阅读和听力的复听。</li>
<li>物理至少复习到光学以前。</li>
<li>使用go开发微信机器人。</li>
</ol>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      silentIris
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://silentiris.github.io/post/W1-bMXR8Q/" title="6.11 周报">https://silentiris.github.io/post/W1-bMXR8Q/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://silentiris.github.io/tag/yxHfiDZjK/"># 周报</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="WebSocket简介与java 实现" href="https://silentiris.github.io/post/6MiJWp4oq/">WebSocket简介与java 实现</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="WebSocket简介与java 实现" href="https://silentiris.github.io/post/6MiJWp4oq/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="code-server安装及配置" href="https://silentiris.github.io/post/1pZxBFCME/">code-server安装及配置</a>
        <a class="nav-mobile-next" title="code-server安装及配置" href="https://silentiris.github.io/post/1pZxBFCME/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      BirthDay = new Date('');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
      <h>hello world!</h>
    </div>
  </footer>
  
    
        <div class="gemini back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
            <span class="scrollpercent"> <span id="back_to_top_text">0</span>% </span>
            
        </div>
        
                  
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "false";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip"> </p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        jQuery.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        jQuery.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        jQuery.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        jQuery.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      jQuery.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      jQuery.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/C4dJJIRWR/"" data-c="
          &lt;p&gt;好长时间没写周报了，前一段时间太忙了。其实说到这个，也并没有忙到周报都写不了，感觉主要的问题是效率太低了，容易受到别的事的影响，这是这一段最主要的问题。这一段干了不少事吧，上一次写还是一个多月前。现在发现周报确实是一个很重要的环节，当自己闲下来就想无头苍蝇一样不知道干什么，提前做好规划和定时总结还是很重要的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完善华五项目。这一周主要跟python打交道，或者说整个比赛都在和python打交道，总的来说就是，痛苦。被py的环境各种折磨，各种各样的报错都见过。在这个环节中其实暴露的问题也挺多的，比如在说说中提到的，太浮躁了，急功近利而沉不下来心。没遇到多少事就想放弃了，而且感觉有些惰于思考，总是希望某个路径或者博客一路走下去就好了，当这条路走不通，就不想思考了。这是非常严重的问题。&lt;/li&gt;
&lt;li&gt;安排科协相关事项：等着挨骂。总的来说，太欠缺考虑了，比如最后拍照环节，还有投屏，空调等，这些都是问题。还有就是去整体安排和策划的能力太差了，只能做到把任务发下去，但是具体完成的怎么样没法保证。应该需要一种行之有效的监督或者查验机制，保证自己发放下去的任务可以被及时正确完成。还有就是需要保证他们都能知道我要传递的信息，这是一个非常难办到的事，很多人对群里的消息根本就没有留心，对于重要的通知甚至不知道，关于如何提高信息的送达率，确实是一个需要学习的技术，仅仅只靠@全体作用并不大。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;关于python与机器学习相关的各种环境部署等依然不是很了解。比如torch，cuda，tensorrt，python都各自是干什么，依赖关系是什么样的，怎样去比较快速而稳定的配置程序需要的运行环境等，这些都是还没有一个准确答案的问题。&lt;/li&gt;
&lt;li&gt;在学习一个新语言的过程中，比如py或者go，总是很快的学习一下基本语法，或者一些基础特性。但是记忆很不牢靠，应用也很不灵活。对这个语言其实还是有很多地方是不了解的。比如py的global之前可能就不了解或者不是很会使用。我们应该怎样快速入门一个语言而且能保证知识的相对全面呢？昨天跟xhh学长聊了聊感觉有一种解决方案就是去dfs，遇到不会的话就一层一层的向下学习，我觉得这是一种非常好的深入了解某个语言底层的方法。&lt;/li&gt;
&lt;li&gt;如何能在管理时调动积极性或是提高通知的送达率，让发出去的通知可以被至少重视和认真阅读呢？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下周规划：&lt;/p&gt;
&lt;p&gt;感觉可以按照大酱的方式来学一学。主要内容是jvm+juc+go吧。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;jvm课程看60集。&lt;/li&gt;
&lt;li&gt;Juc课程看60集。&lt;/li&gt;
&lt;li&gt;go by example跟着教程写完，以及把涉及到的每一个知识点复习一下。&lt;/li&gt;
&lt;li&gt;复习数据结构：复习栈的应用。&lt;/li&gt;
&lt;/ol&gt;
">10.15 周报</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/CmUMwLjIW/"" data-c="
          &lt;h1 id=&#34;拆分模块&#34;&gt;拆分模块&lt;/h1&gt;
&lt;h2 id=&#34;模块拆分策略&#34;&gt;模块拆分策略：&lt;/h2&gt;
&lt;h3 id=&#34;按职责划分&#34;&gt;按职责划分&lt;/h3&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;--order
&lt;ul&gt;
&lt;li&gt;--service&lt;/li&gt;
&lt;li&gt;--po&lt;/li&gt;
&lt;li&gt;--controller&lt;/li&gt;
&lt;li&gt;--dao&lt;/li&gt;
&lt;li&gt;--common&lt;/li&gt;
&lt;li&gt;--util&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;按功能划分&#34;&gt;按功能划分&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;--service
&lt;ul&gt;
&lt;li&gt;--pay&lt;/li&gt;
&lt;li&gt;--order&lt;/li&gt;
&lt;li&gt;--manage&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;依赖冲突&#34;&gt;依赖冲突&lt;/h1&gt;
&lt;h2 id=&#34;查看依赖冲突&#34;&gt;查看依赖冲突&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;通过&lt;code&gt;mvn -Dverbose dependency:tree&lt;/code&gt;来查看。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果有&lt;code&gt;omitted for duplicate&lt;/code&gt;表示有jar包被重复依赖，最后写着&lt;code&gt;omitted for conflict with xxx&lt;/code&gt;的，说明和别的jar包版本冲突了，而该行的jar包不会被引入。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;idea可以用maven helper查看&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;解决方式&#34;&gt;解决方式&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;第一声明优先：即在pom.xml文件自上而下，先声明的jar坐标，就先引用该jar的传递依赖。&lt;/li&gt;
&lt;li&gt;路径最短者优先：即直接依赖的级别高于依赖传递。可以在最外层来定义某个依赖的版本来统一版本。&lt;/li&gt;
&lt;li&gt;排除依赖：如果导入某个包的时候不想要其中的某个依赖，可以用&lt;code&gt;&amp;lt;exclusions&amp;gt;&lt;/code&gt;标签。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.2.7.RELEASE&amp;lt;/version&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;artifactId&amp;gt;spring-core&amp;lt;/artifactId&amp;gt;
                    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码即可排除``org.springframewor`这个依赖。&lt;/p&gt;
&lt;h1 id=&#34;搭建多模块项目&#34;&gt;搭建多模块项目&lt;/h1&gt;
&lt;h2 id=&#34;父模块&#34;&gt;父模块&lt;/h2&gt;
&lt;p&gt;使用idea初始化父项目，什么依赖都不需要加，仅用于管理。父模块可以仅留下pom和.gitignore。&lt;/p&gt;
&lt;p&gt;在父工程的pom文件中可以设置项目相关属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义子模块&lt;br&gt;
可以在&lt;code&gt;&amp;lt;modules&amp;gt;&lt;/code&gt;属性中定义子模块。&lt;code&gt;&amp;lt;module&amp;gt;&lt;/code&gt;中填写子模块的名称&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--父模块--&amp;gt;
&amp;lt;modules&amp;gt;  
    &amp;lt;module&amp;gt;user-service&amp;lt;/module&amp;gt;  
    &amp;lt;module&amp;gt;order-service&amp;lt;/module&amp;gt;  
    &amp;lt;module&amp;gt;eureka-server&amp;lt;/module&amp;gt;  
&amp;lt;/modules&amp;gt;
&amp;lt;!--子模块的parent属性--&amp;gt;
&amp;lt;parent&amp;gt;  
    &amp;lt;groupId&amp;gt;com.sipc&amp;lt;/groupId&amp;gt;  
    &amp;lt;!--子模块名，和上方的module名一样--&amp;gt;
    &amp;lt;artifactId&amp;gt;cloud-learn&amp;lt;/artifactId&amp;gt;  
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;  
&amp;lt;/parent&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;更换打包方式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pom 是最简单的打包类型。不像jar和war，它生成的构件只有它本身。将 &lt;strong&gt;packaging&lt;/strong&gt; 申明为 &lt;strong&gt;pom&lt;/strong&gt; 则意味着没有代码需要测试或者编译，也没有资源需要处理。&lt;br&gt;
由于我们使用了聚合，所以打包方式必须为pom，否则无法构建。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自定义属性&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;properties&amp;gt;  
    &amp;lt;spring-cloud.version&amp;gt;2022.0.4&amp;lt;/spring-cloud.version&amp;gt;  
    &amp;lt;spring-cloud-alibaba.version&amp;gt;2022.0.0.0&amp;lt;/spring-cloud-alibaba.version&amp;gt;  
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;  
    &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;  
    &amp;lt;java.version&amp;gt;17&amp;lt;/java.version&amp;gt;  
&amp;lt;/properties&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以在这里定义一些变量，以便后续的依赖快速修改版本等。后面的依赖可以直接使用&lt;code&gt;&amp;lt;version&amp;gt;${spring-cloud-alibaba.version}&amp;lt;/version&amp;gt;&lt;/code&gt;这样的方式来定义依赖版本。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义统一依赖管理dependencyManagement&lt;br&gt;
在Maven中，当父模块定义了&lt;code&gt;&amp;lt;dependencies&amp;gt;&lt;/code&gt;元素时，子模块可以直接使用这些依赖项。子模块不需要再次指定版本号，而是可以直接引用父模块中定义的依赖项。当需要变更版本号的时候只需要在父类容器里更新，不需要任何一个子项目的修改；如果某个子项目需要另外一个特殊的版本号时，只需要在自己的模块dependencies中声明一个版本号即可。子类就会使用子类声明的版本号，不继承于父类版本号。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencyManagement&amp;gt;  
    &amp;lt;dependencies&amp;gt;        
    &amp;lt;!--阿里巴巴下载仓库--&amp;gt;  
        &amp;lt;dependency&amp;gt;  
            &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt;  
            &amp;lt;artifactId&amp;gt;spring-cloud-alibaba-dependencies&amp;lt;/artifactId&amp;gt;  
            &amp;lt;version&amp;gt;${spring-cloud-alibaba.version}&amp;lt;/version&amp;gt;  
            &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;  
            &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;  
        &amp;lt;/dependency&amp;gt;        
        &amp;lt;!-- springCloud --&amp;gt;  
        &amp;lt;dependency&amp;gt;  
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;  
            &amp;lt;!--是springcloud为了管理依赖所创造的依赖，里面有springcloud的所有依赖--&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;  
            &amp;lt;version&amp;gt;${spring-cloud.version}&amp;lt;/version&amp;gt;  
	        &amp;lt;!--pom的意思是仅作为pom引入，不导入实际jar包--&amp;gt;
            &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;  
            &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;  
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- mysql--&amp;gt;    
	    &amp;lt;dependency&amp;gt;
	        &amp;lt;groupId&amp;gt;mysq1&amp;lt;/groupId&amp;gt;
	        &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
	        &amp;lt;version&amp;gt;5.1.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/dependencyManagement&amp;gt;
&amp;lt;!--子项目中只需要声明groupId喝artifactId--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与&lt;code&gt;&amp;lt;dependencies&amp;gt;&lt;/code&gt;的区别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Dependencies相对于dependencyManagement，所有生命在dependencies里的依赖都会自动引入，并默认被所有的子项目继承。&lt;/li&gt;
&lt;li&gt;dependencyManagement里只是声明依赖，并不自动实现引入，因此子项目需要显示的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom;另外如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;子模块&#34;&gt;子模块&lt;/h2&gt;
&lt;p&gt;在父模块之下建立一个子模块，需要在pom文件修改属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义父模块&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;parent&amp;gt;  
    &amp;lt;groupId&amp;gt;com.sipc&amp;lt;/groupId&amp;gt;  
    &amp;lt;!--工件Id要和parent一致--&amp;gt;
    &amp;lt;artifactId&amp;gt;cloud-learn&amp;lt;/artifactId&amp;gt;  
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;  
&amp;lt;/parent&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;添加该模块需要的依赖&lt;br&gt;
如果在父模块的&lt;code&gt;&amp;lt;dependencyManagement&amp;gt;&lt;/code&gt;定义过就不需要写version。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ps. 如果想导入其他子模块，需要在 &lt;code&gt;dependency&lt;/code&gt; 中引入要依赖的子模块。我们依然应该使用在父模块声明&lt;code&gt;&amp;lt;dependencyManagement&amp;gt;&lt;/code&gt;来集中管理版本。在其他子模块只需要导入groupId和artifactId，版本由父项目统一管理。&lt;/p&gt;
&lt;p&gt;例如：父工程pom：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;com.sipc&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;user-service&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${order-service.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在user-service的pom引入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.sipc&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;order-service&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即可在user-service中使用order-service的暴露给外界的接口。&lt;/p&gt;
&lt;p&gt;Referrence：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844904198220283918&#34;&gt;maven依赖冲突以及解决方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844903970024980488&#34;&gt;maven多模块管理&lt;/a&gt;&lt;/p&gt;
">maven多模块管理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/yNLZEJkro/"" data-c="
          &lt;p&gt;项目地址：&lt;a href=&#34;https://github.com/wanhebin/clash-for-linux&#34;&gt;clash-for-linux&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先是&lt;code&gt;sh start.sh&lt;/code&gt;可能会启动不成功。在有些os中&lt;code&gt;/bin/sh&lt;/code&gt;被更改为了dash。&lt;br&gt;
可以用&lt;code&gt;bash start.sh&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在我运行时候提示运行成功，但是&lt;code&gt;lsof -i:7890&lt;/code&gt;发现没有开启服务，&lt;code&gt;curl google.com&lt;/code&gt;也无法连接。&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1.png&#34; alt=&#34;Pasted image 20231005000833&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还试了chmod -x ，但是也没有解决，还尝试了很多方法，都没有作用，唯独忽略了去看日志，这是一个非常不好的习惯和错误。遇到了问题应该第一时间看日志的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​	后来去./logs找到了日志，cat之后&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://silentiris.github.io/post-images/2.png&#34; alt=&#34;Pasted image 20231005001608&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现&lt;img src=&#34;https://silentiris.github.io/post-images/3.png&#34; alt=&#34;Pasted image 20231005001704&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;提示找不到这个bin....&lt;/p&gt;
&lt;p&gt;后来cd到了bin目录，发现名字真的有问题....晕&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/4.png&#34; alt=&#34;Pasted image 20231005001754&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;mv clash-linux-amd64-v1.13.0 clash-linux-amd64&lt;/code&gt;后，再启动就好了。&lt;/p&gt;
&lt;p&gt;第二个问题困扰了我很长时间，没想到最后用这种方式解决了。。。这给我两个启示&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;出现问题一定要记得看日志！！！&lt;/li&gt;
&lt;li&gt;在自己编写接口和服务时一定要注意给予正确的反馈，不能像这种明明都没有启动还提示启动成功的。&lt;/li&gt;
&lt;/ol&gt;
">记录一次clash-for-linux的运行错误</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/PiUA5PSmk/"" data-c="
          &lt;h1 id=&#34;question&#34;&gt;question&lt;/h1&gt;
&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，找到 &lt;code&gt;s&lt;/code&gt; 中最长的回文子串。&lt;/p&gt;
&lt;p&gt;如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：s = &amp;quot;babad&amp;quot;
输出：&amp;quot;bab&amp;quot;
解释：&amp;quot;aba&amp;quot; 同样是符合题意的答案。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：s = &amp;quot;cbbd&amp;quot;
输出：&amp;quot;bb&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= s.length &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 仅由数字和英文字母组成&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;my-solution&#34;&gt;my solution&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution
{
public:
    string convert(string s, int numRows)
    {
        if(numRows == 1) return s;
        int cols = (s.size() / (2 * numRows - 2) + 1) * (numRows - 1) ;
        int curRow = 0;
        int curCol = 0;
        vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; res(numRows, vector&amp;lt;char&amp;gt;(cols, &#39;\0&#39;));
        int i = 0;
        bool flag = false;
        while (true)
        {
            while (curRow &amp;lt; numRows -1)
            {
                if (i == s.size())
                {
                    flag = true;
                    break;
                }
                res[curRow][curCol] = s[i];
                curRow++;
                i++;
            }
            while (curRow &amp;gt; 0)
            {
                if (i == s.size())
                {
                    flag = true;
                    break;
                }
                res[curRow][curCol] = s[i];
                curCol++;
                curRow--;
                i++;
            }
            if (flag)
                break;
        }
        string resStr = &amp;quot;&amp;quot;;
        for (int row = 0; row &amp;lt; numRows; row++)
        {
            for (int col = 0; col &amp;lt; cols; col++)
            {
                if (res[row][col] != &#39;\0&#39;)
                    resStr = resStr + res[row][col];
            }
        }
        return resStr;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;复盘&#34;&gt;复盘&lt;/h1&gt;
&lt;p&gt;这里的思路是先造一个大数组，然后按照顺序插入，最后遍历。最后遍历的耗时有点长，时间复杂度应该主要来源于此。&lt;/p&gt;
&lt;p&gt;后续更优的算法其实心里大概有思路，可惜不知道怎么实现。还是经验不够吧。&lt;/p&gt;
&lt;p&gt;可以优化的地方&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt; int t = r * 2 - 2;
 int c = (n + t - 1) / t * (r - 1);

 利用 i % t &amp;lt; r - 1 来判断状态，更加简洁统一。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;其他思路&#34;&gt;其他思路&lt;/h2&gt;
&lt;h3 id=&#34;压缩矩阵空间&#34;&gt;压缩矩阵空间&lt;/h3&gt;
&lt;p&gt;my solution中的矩阵有大量的空间没有被使用，可以优化。&lt;/p&gt;
&lt;p&gt;注意到每次往矩阵的某一行添加字符时，都会添加到该行上一个字符的右侧，且最后组成答案时只会用到每行的非空字符。因此我们可以将矩阵的每行初始化为一个空列表，每次向某一行添加字符时，添加到该行的列表末尾即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    string convert(string s, int numRows) {
        int n = s.length(), r = numRows;
        if (r == 1 || r &amp;gt;= n) {
            return s;
        }
        vector&amp;lt;string&amp;gt; mat(r);
        for (int i = 0, x = 0, t = r * 2 - 2; i &amp;lt; n; ++i) {
            mat[x] += s[i];
            i % t &amp;lt; r - 1 ? ++x : --x;
        }
        string ans;
        for (auto &amp;amp;row : mat) {
            ans += row;
        }
        return ans;
    }
};
链接：https://leetcode.cn/problems/zigzag-conversion/solutions/1298127/z-zi-xing-bian-huan-by-leetcode-solution-4n3u/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;直接构造&#34;&gt;直接构造&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://silentiris.github.io/post-images/image-20230904204953587.png&#34; alt=&#34;image-20230904204953587&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    string convert(string s, int numRows) {
        int n = s.length(), r = numRows;
        if (r == 1 || r &amp;gt;= n) {
            return s;
        }
        string ans;
        int t = r * 2 - 2;
        for (int i = 0; i &amp;lt; r; ++i) { // 枚举矩阵的行
            for (int j = 0; j + i &amp;lt; n; j += t) { // 枚举每个周期的起始下标
                ans += s[j + i]; // 当前周期的第一个字符
                if (0 &amp;lt; i &amp;amp;&amp;amp; i &amp;lt; r - 1 &amp;amp;&amp;amp; j + t - i &amp;lt; n) {
                    ans += s[j + t - i]; // 当前周期的第二个字符
                }
            }
        }
        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">leetcode [6] N 字形变换</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/dWISQCv_S/"" data-c="
          &lt;h1 id=&#34;question&#34;&gt;question&lt;/h1&gt;
&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，找到 &lt;code&gt;s&lt;/code&gt; 中最长的回文子串。&lt;/p&gt;
&lt;p&gt;如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：s = &amp;quot;babad&amp;quot;
输出：&amp;quot;bab&amp;quot;
解释：&amp;quot;aba&amp;quot; 同样是符合题意的答案。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：s = &amp;quot;cbbd&amp;quot;
输出：&amp;quot;bb&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= s.length &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 仅由数字和英文字母组成&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;my-solution&#34;&gt;my solution&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution
{
public:
    string longestPalindrome(string s)
    {
        pair&amp;lt;int, int&amp;gt; res(0, 0);
        for (int i = 0; i &amp;lt; s.size(); i++)
        {
            for (int j = s.size() - 1; j &amp;gt;= i; j--)
            {
                bool flag = false;
                if (s[j] == s[i])
                {
                    int lpos = i, rpos = j;
                    int len = 0;
                    while (lpos &amp;lt; rpos)
                    {
                        if (s[lpos] != s[rpos])
                            break;
                        lpos++;
                        rpos--;
                        len++;
                    }
                    if (lpos == rpos &amp;amp;&amp;amp; 2 * len + 1 &amp;gt; res.first)
                    {
                        res.first = 2 * len + 1;
                        res.second = i;
                        flag = true;
                    }
                    else if (2 * len &amp;gt; res.first &amp;amp;&amp;amp; lpos &amp;gt;= rpos)
                    {
                        res.first = 2 * len;
                        res.second = i;
                        flag = true;
                    }
                }
                if (flag)
                    break;
            }
        }
        string resStr = s.substr(res.second, res.first);
        return resStr;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;复盘&#34;&gt;复盘&lt;/h1&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;p&gt;算是暴力，对于每一个字符，找他后面的和他相同的字符，再依此判断是不是回文，但居然没tle，可能卡到了某些奇怪的时间，但是算法也很烂了。时间复杂度极高，而且中间有各种小问题，对于某些边界条件等不是很清楚。&lt;/p&gt;
&lt;h2 id=&#34;更优解法&#34;&gt;更优解法&lt;/h2&gt;
&lt;h2 id=&#34;动态规划&#34;&gt;动态规划&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        String res = &amp;quot;&amp;quot;;
        boolean[][] dp = new boolean[n][n];
        for (int i = n - 1; i &amp;gt;= 0; i--) {
            for (int j = i; j &amp;lt; n; j++) {
                dp[i][j] = s.charAt(i) == s.charAt(j) &amp;amp;&amp;amp; (j - i &amp;lt; 2 || dp[i + 1][j - 1]);
                if (dp[i][j] &amp;amp;&amp;amp;  j - i + 1 &amp;gt; res.length()) {
                    res = s.substring(i, j + 1);
                }
            }
        }
        return res;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://silentiris.github.io/post-images/image-20230904202003536.png&#34; alt=&#34;image-20230904202003536&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;中心扩散&#34;&gt;中心扩散&lt;/h2&gt;
&lt;p&gt;我们知道回文串一定是对称的，所以我们可以每次循环选择一个中心，进行左右扩展，判断左右字符是否相等即可。&lt;/p&gt;
&lt;p&gt;由于存在奇数的字符串和偶数的字符串，所以我们需要从一个字符开始扩展，或者从两个字符之间开始扩展，所以总共有 n+n-1 个中心。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public String longestPalindrome(String s) {
    if (s == null || s.length() &amp;lt; 1) return &amp;quot;&amp;quot;;
    int start = 0, end = 0;
    for (int i = 0; i &amp;lt; s.length(); i++) {
        int len1 = expandAroundCenter(s, i, i);
        int len2 = expandAroundCenter(s, i, i + 1);
        int len = Math.max(len1, len2);
        if (len &amp;gt; end - start) {
            start = i - (len - 1) / 2;
            end = i + len / 2;
        }
    }
    return s.substring(start, end + 1);
}

private int expandAroundCenter(String s, int left, int right) {
    int L = left, R = right;
    while (L &amp;gt;= 0 &amp;amp;&amp;amp; R &amp;lt; s.length() &amp;amp;&amp;amp; s.charAt(L) == s.charAt(R)) {
        L--;
        R++;
    }
    return R - L - 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里值得注意的是用一个方法统一了奇数偶数两种情乱。&lt;/p&gt;
&lt;h2 id=&#34;manachers-algorithm-on&#34;&gt;Manacher&#39;s Algorithm （O(n)）&lt;/h2&gt;
&lt;p&gt;不会&lt;/p&gt;
&lt;p&gt;链接：https://leetcode.cn/problems/longest-palindromic-substring/solutions/9001/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu/&lt;/p&gt;
">leetcode [5] 最长回文子串</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/dKkjiAPLa/"" data-c="
          &lt;p&gt;上一周还是比较充实的，果然在115效率还是高很多。上一星期学的比较多也比较杂。现在用ms的todo list，给每天做规划，感觉还是不错的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;复习了sping cloud。第一次学的时候基本就是过了一下，看了一眼视频，理解的非常浅。这一遍又实现了小demo，折腾了一下环境配置，还有maven一些高级点的配置，对多模块有一些大致了解。下一个项目感觉可以做多模块了。果然还是写demo才能稍微熟悉一些。顺便还发现之前idea那个逆天的yaml识别不出来配置文件的bug。&lt;/li&gt;
&lt;li&gt;每天一道力扣。算法慢慢学一点把，顺便也复建一下，不要太拉了。做力扣的时候会先自己做，ac之后复盘，找更好的的做法和题解，记录博客更新。不过有些题还是太难惹5555。&lt;/li&gt;
&lt;li&gt;看数据结构。看到70，该看b树了。值得注意的是这个也就是整体过一遍了。以后肯定还是要代码巩固的，比如刷题的时候发现对基本数据结构还是太不熟悉了，甚至写个链表都要写半天。&lt;/li&gt;
&lt;li&gt;看acwing的课。规划每周两节把，上周看了stl的和快排和二分。说实话，感觉理解的程度也不是很高，属于看过就忘。可能还是没完全听明白或者是没做题巩固吧。上一周做leetcode [4]的时候就看那个二分半天没明白。&lt;/li&gt;
&lt;li&gt;复习maven。对于maven的稍微进阶的用法更了解一点。比如依赖冲突，多模块项目等。第一次学的时候只是过了一下，发现根本就不会用。现在的了解稍微多一点了。&lt;/li&gt;
&lt;li&gt;每晚跑步。&lt;/li&gt;
&lt;li&gt;处理科协的事，主要是宣传类的还有回答考题。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于有时候自己明白某个算法实现原理，但是自己写的时候问题很多，比如写第四题的双指针的时候很蠢，各种问题接踵而至，感觉很混乱，哪里出问题补哪里，对于算法或者程序整体的问题不是很明晰，不知道怎样改善。&lt;/li&gt;
&lt;li&gt;对于很多技术栈感觉只能说是看了看视频，知道整体情况下最多的一种用法，但是还有很多细节是不知道的，感觉自己看文档或者博客学习的能力有点低了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下周规划：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据结构往后10集。&lt;/li&gt;
&lt;li&gt;数据结构题集写完线性表。&lt;/li&gt;
&lt;li&gt;对于后端的技术栈学的不是很透的继续熟悉，具体的见每日任务吧。想到什么添加到task中，及时学习。&lt;/li&gt;
&lt;li&gt;每天一道力扣。&lt;/li&gt;
&lt;li&gt;每晚跑步。&lt;/li&gt;
&lt;li&gt;开始搞华五的项目。&lt;/li&gt;
&lt;li&gt;继续复习一些java基础。&lt;/li&gt;
&lt;li&gt;科协纳新事项&lt;/li&gt;
&lt;/ol&gt;
">9.3 周报</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/rN_Hzfto7/"" data-c="
          &lt;h1 id=&#34;question&#34;&gt;question&lt;/h1&gt;
&lt;p&gt;给定两个大小分别为 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 的正序（从小到大）数组 &lt;code&gt;nums1&lt;/code&gt; 和 &lt;code&gt;nums2&lt;/code&gt;。请你找出并返回这两个正序数组的 &lt;strong&gt;中位数&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;算法的时间复杂度应该为 &lt;code&gt;O(log (m+n))&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nums1.length == m&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums2.length == n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= m &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= n &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= m + n &amp;lt;= 2000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-106 &amp;lt;= nums1[i], nums2[i] &amp;lt;= 106&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;标签：&lt;/p&gt;
&lt;p&gt;数组，二分查找，分支&lt;/p&gt;
&lt;h1 id=&#34;my-solution&#34;&gt;my solution&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    double findMedianSortedArrays(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2) {
        vector&amp;lt;int&amp;gt; resVec ;
        resVec.insert(resVec.end(),nums1.begin(),nums1.end());
        resVec.insert(resVec.end(),nums2.begin(),nums2.end());
        sort(resVec.begin(),resVec.end());
        int size = resVec.size();
        if(size%2 == 0){
            return (resVec[size/2-1] + resVec[size/2 ])/(double)2;
        }else{
            return resVec[size/2];
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;复盘&#34;&gt;复盘&lt;/h1&gt;
&lt;p&gt;蠢。没仔细看题，直接用最暴力的方式加起来sort，直接O(nlogn)，虽然ac，但是其实还是没想出来log(m+n)的算法。甚至连双指针这种还稍微好一点的算法都没想到。太不认真了，思维应该再缜密一点。&lt;/p&gt;
&lt;h3 id=&#34;要改进的地方&#34;&gt;要改进的地方&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;好好看题&lt;/li&gt;
&lt;li&gt;对于常见算法的时间复杂度不是很清晰&lt;/li&gt;
&lt;li&gt;思维过于直接，没有思考性能更优秀的算法&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;更好的处理方式&#34;&gt;更好的处理方式&lt;/h3&gt;
&lt;h4 id=&#34;1暴力归并&#34;&gt;1.暴力（归并）&lt;/h4&gt;
&lt;p&gt;处理逻辑：&lt;/p&gt;
&lt;p&gt;合并 nums1，nums2 为第三个数组&lt;br&gt;
排序第三个数组&lt;br&gt;
按下标，找出中位数&lt;br&gt;
因为 nums1 ，nums2 本身就是按从小到大排序好了的； 使用归并，一个一个的从 nums1 ，nums2 里面取出最小的数，放到第三个数组中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
	res := make([]int, 0)
	i, j := 0, 0
	if len(nums1)*len(nums2) == 0 {
		res = append(res, nums1...)
		res = append(res, nums2...)
	} else {
		for i &amp;lt; len(nums1) || j &amp;lt; len(nums2) {
			if nums1[i] &amp;gt; nums2[j] {
				res = append(res, nums2[j])
				if j == len(nums2)-1 {
					res = append(res, nums1[i:]...)
					break
				}
				j += 1
			} else {
				res = append(res, nums1[i])
				if i == len(nums1)-1 {
					res = append(res, nums2[j:]...)
					break
				}
				i += 1
			}
		}
	}
	totalLen := len(nums1) + len(nums2)
	if totalLen%2 == 0 {
		return float64((res[totalLen/2-1] + res[totalLen/2])) / 2.0
	} else {
		return float64(res[totalLen/2])
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2双指针&#34;&gt;2.双指针&lt;/h4&gt;
&lt;p&gt;处理逻辑：&lt;/p&gt;
&lt;p&gt;申请2个指针，分别指向2个数组的头&lt;br&gt;
每次比较大小来移动 2个指针&lt;br&gt;
当指针移动的次数与 (m + n) / 2 相同时，得到中位数&lt;br&gt;
注意边界问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2个指针在移动时，是否有超过2个数组的最大个数；
如果有，后续就只能移动另一个指针
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
	i, j := 0, 0
	mov := 0
	totalLen := len(nums1) + len(nums2)
	if len(nums1)*len(nums2) == 0 {
		if len(nums1) == 0 {
			if len(nums2)%2 == 0 {
				return float64(nums2[len(nums2)/2]+nums2[len(nums2)/2-1]) / 2.0
			} else {
				return float64(nums2[len(nums2)/2])
			}
		} else {
			return findMedianSortedArrays(nums2, nums1)
		}
	} else {
		for mov &amp;lt; totalLen/2 {
			if i != len(nums1) &amp;amp;&amp;amp; j != len(nums2) {
				if nums1[i] &amp;lt; nums2[j] {
					i += 1
					mov += 1
				} else {
					j += 1
					mov += 1
				}
			} else {
				if i == len(nums1) {
					j += 1
					mov += 1
				} else {
					i += 1
					mov += 1
				}
			}
		}
	}
	if totalLen%2 == 0 {
		var lmax int
		if i == 0 {
			lmax = nums2[j-1]
		} else if j == 0 {
			lmax = nums1[i-1]
		} else {
			lmax = getMax(nums1[i-1], nums2[j-1])
		}
		var rmin int
		if i == len(nums1) || j == len(nums2) {
			if i == len(nums1) {
				rmin = nums2[j]
			} else {
				rmin = nums1[i]
			}
		} else {
			rmin = getMin(nums1[i], nums2[j])
		}
		return float64(rmin+lmax) / 2.0
	} else {
		if i == len(nums1) {
			return float64(nums2[j])
		} else if j == len(nums2) {
			return float64(nums1[i])
		} else {
			return float64(getMin(nums1[i], nums2[j]))
		}
	}
}
func getMax(x, y int) int {
	if x &amp;gt; y {
		return x
	} else {
		return y
	}
}
func getMin(x, y int) int {
	if x &amp;gt; y {
		return y
	} else {
		return x
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-二分查找最优算法logmn&#34;&gt;3. 二分查找（最优算法，log(m+n)）&lt;/h4&gt;
&lt;h3 id=&#34;不会-放弃了&#34;&gt;不会 放弃了&lt;/h3&gt;
">leetcode [4] 寻找两个正序数组的中位数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/bqJESDfVa/"" data-c="
          &lt;h1 id=&#34;question&#34;&gt;question&lt;/h1&gt;
&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你找出其中不含有重复字符的 &lt;strong&gt;最长子串&lt;/strong&gt; 的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: s = &amp;quot;abcabcbb&amp;quot;
输出: 3 
解释: 因为无重复字符的最长子串是 &amp;quot;abc&amp;quot;，所以其长度为 3。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: s = &amp;quot;bbbbb&amp;quot;
输出: 1
解释: 因为无重复字符的最长子串是 &amp;quot;b&amp;quot;，所以其长度为 1。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: s = &amp;quot;pwwkew&amp;quot;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;quot;wke&amp;quot;，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，&amp;quot;pwke&amp;quot; 是一个子序列，不是子串。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= s.length &amp;lt;= 5 * 104&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 由英文字母、数字、符号和空格组成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相关标签：&lt;/p&gt;
&lt;p&gt;哈希表，字符串，滑动窗口&lt;/p&gt;
&lt;h1 id=&#34;my-solution&#34;&gt;my solution&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func lengthOfLongestSubstring(s string) int {
	resSlice := make([]int, 0)
	for i := 0; i &amp;lt; len(s)-1; i++ {
		m := make(map[rune]int)
		m[rune(s[i])] = 1
		resSlice = append(resSlice,1)
		j := i + 1
		for m[rune(s[j])] == 0 {
			m[rune(s[j])] = 1
			resSlice[i] += 1
			if j==len(s) - 1 {
				break
			}
			j += 1
		}
	}
	res := 1;
	for _,value := range resSlice {
		if value &amp;gt; res {
			res = value
		}
	}
	if s==&amp;quot;&amp;quot;{
		res = 0
	}
	return res
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;复盘&#34;&gt;复盘&lt;/h1&gt;
&lt;p&gt;这个题的解决方式很蠢，直接暴力遍历每个数，不过在遍历的时候用到了map（或者这里的作用和set是一样的），下一个数map中没有的话就+1，有的话就结束for下一个。好在题目数据量不大，还勉强能过。通过这道题了解了一下滑动窗口算法。顺便发现go的基础太差了，比如rune，map构造，map里的类型转换(&lt;code&gt;m[rune(s[j])]&lt;/code&gt;)等，for循环等，还要复习一下基础。还有对&amp;quot;&amp;quot;的特判意识不够，考虑不是很全面。&lt;/p&gt;
&lt;h2 id=&#34;问题&#34;&gt;问题：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;了解贪心和滑动窗口&lt;/li&gt;
&lt;li&gt;go基础。（循环，切片，map，数据类型等）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;更好的处理方式&#34;&gt;更好的处理方式&lt;/h2&gt;
&lt;h3 id=&#34;滑动窗口&#34;&gt;滑动窗口：&lt;/h3&gt;
&lt;p&gt;leetcode官方：&lt;/p&gt;
&lt;p&gt;如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 rk。那么当我们选择第 k+1个字符作为起始位置时，首先从 k+1到 rk的字符显然是不重复的，并且由于少了原本的第k个字符，我们可以尝试继续增大 rk ，直到右侧出现了重复字符为止。&lt;/p&gt;
&lt;p&gt;这样一来，我们就可以使用「滑动窗口」来解决这个问题了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的rk;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在每一步的操作中，我们会将左指针向右移动一格，表示 我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在枚举结束后，我们找到的最长的子串的长度即为答案。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func lengthOfLongestSubstring(s string) int {
    // 哈希集合，记录每个字符是否出现过
    m := map[byte]int{}
    n := len(s)
    // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
    rk, ans := -1, 0
    for i := 0; i &amp;lt; n; i++ {
        if i != 0 {
            // 左指针向右移动一格，移除一个字符
            delete(m, s[i-1])
        }
        for rk + 1 &amp;lt; n &amp;amp;&amp;amp; m[s[rk+1]] == 0 {
            // 不断地移动右指针
            m[s[rk+1]]++
            rk++
        }
        // 第 i 到 rk 个字符是一个极长的无重复字符子串
        ans = max(ans, rk - i + 1)
    }
    return ans
}

func max(x, y int) int {
    if x &amp;lt; y {
        return y
    }
    return x
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;判断重复字符&#34;&gt;判断重复字符：&lt;/h4&gt;
&lt;p&gt;上面的流程使用哈希集合。也可以使用数组(用ascii码来记录字符)来判断是否有重复字符。&lt;/p&gt;
">leetcode [3] 无重复字符的最长子串</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/6Isj6BIHr/"" data-c="
          &lt;h1 id=&#34;question&#34;&gt;question:&lt;/h1&gt;
&lt;p&gt;给你两个 &lt;strong&gt;非空&lt;/strong&gt; 的链表，表示两个非负的整数。它们每位数字都是按照 &lt;strong&gt;逆序&lt;/strong&gt; 的方式存储的，并且每个节点只能存储 &lt;strong&gt;一位&lt;/strong&gt; 数字。&lt;/p&gt;
&lt;p&gt;请你将两个数相加，并以相同形式返回一个表示和的链表。&lt;/p&gt;
&lt;p&gt;你可以假设除了数字 0 之外，这两个数都不会以 0 开头。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：l1 = [0], l2 = [0]
输出：[0]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个链表中的节点数在范围 &lt;code&gt;[1, 100]&lt;/code&gt; 内&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= Node.val &amp;lt;= 9&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;题目数据保证列表表示的数字不含前导零&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相关标签：&lt;br&gt;
递归，链表，数学&lt;/p&gt;
&lt;h1 id=&#34;my-solution&#34;&gt;my solution:&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution
{
public:
    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2)
    {
        int len1 = 1;
        int len2 = 1;
        ListNode *temp = l1;
        while (temp-&amp;gt;next != nullptr)
        {
            temp = temp-&amp;gt;next;
            len1++;
        }
        temp = l2;
        while (temp-&amp;gt;next != nullptr)
        {
            temp = temp-&amp;gt;next;
            len2++;
        }
        if (len1 &amp;gt;= len2)
        {
            ListNode *resNode = l1;
            for (int i = 0; i &amp;lt; len1; i++)
            {
                l1-&amp;gt;val = l1-&amp;gt;val + l2-&amp;gt;val;
                if (l1-&amp;gt;val &amp;gt;= 10 &amp;amp;&amp;amp; i != len1 - 1)
                {
                    l1-&amp;gt;next-&amp;gt;val++;
                    l1-&amp;gt;val -= 10;
                }
                else if (l1-&amp;gt;val &amp;gt;= 10 &amp;amp;&amp;amp; i == len1 - 1)
                {
                    l1-&amp;gt;val -= 10;
                    ListNode *lastNode = new ListNode(1, nullptr);
                    l1-&amp;gt;next = lastNode;
                }
                if (i != len1 - 1)
                {
                    l1 = l1-&amp;gt;next;
                    if (l2-&amp;gt;next != nullptr)
                        l2 = l2-&amp;gt;next;
                    else
                        l2-&amp;gt;val = 0;
                }
            }
            return resNode;
        }
        else
        {
            ListNode *resNode = l2;
            for (int i = 0; i &amp;lt; len2; i++)
            {
                l2-&amp;gt;val = l1-&amp;gt;val + l2-&amp;gt;val;
                if (l2-&amp;gt;val &amp;gt;= 10 &amp;amp;&amp;amp; i != len2 - 1)
                {
                    l2-&amp;gt;next-&amp;gt;val++;
                    l2-&amp;gt;val -= 10;
                }
                else if (l2-&amp;gt;val &amp;gt;= 10 &amp;amp;&amp;amp; i == len2 - 1)
                {
                    l2-&amp;gt;val -= 10;
                    ListNode *lastNode = new ListNode(1, nullptr);
                    l2-&amp;gt;next = lastNode;
                }
                if (i != len2 - 1)
                {
                    l2 = l2-&amp;gt;next;
                    if (l1-&amp;gt;next != nullptr)
                        l1 = l1-&amp;gt;next;
                    else
                        l1-&amp;gt;val = 0;
                }
            }
            return resNode;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;复盘&#34;&gt;复盘：&lt;/h1&gt;
&lt;p&gt;这道题刚开始写的时候犯了很严重的问题，题目的数据范围都没有看清楚， 导致从开始的思路就是错的，最开始想两数相加然后再逆序构造链表，在写的过程中还发现我对于构造链表和一些基础内容比如求整数的某位数字等还不熟练，问题很大。后来发现不对，开始思考另一种方式。想到绕过链表的构造，直接用现成的链表，这种方法有一定的效果，并且最终做了出来。但是在对于l1,l2 长度的问题处理上依然不够优雅。&lt;/p&gt;
&lt;p&gt;可以优化的地方：else后面的第二种情况可以直接写成&lt;code&gt;return addTwoNumbers(l2,l1);&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;值得关注的问题&#34;&gt;值得关注的问题：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;链表的构造&lt;/li&gt;
&lt;li&gt;c++，go的基础语法&lt;/li&gt;
&lt;li&gt;快速求数字的位数和某位的数字&lt;/li&gt;
&lt;li&gt;对于多情况下的处理&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;更好的处理方式&#34;&gt;更好的处理方式：&lt;/h2&gt;
&lt;h3 id=&#34;1-模拟&#34;&gt;1. 模拟&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* dummy = new ListNode();
        int carry = 0;
        ListNode* cur = dummy;
        while (l1 || l2 || carry) {
            int s = (l1 ? l1-&amp;gt;val : 0) + (l2 ? l2-&amp;gt;val : 0) + carry;
            carry = s / 10;
            cur-&amp;gt;next = new ListNode(s % 10);
            cur = cur-&amp;gt;next;
            l1 = l1 ? l1-&amp;gt;next : nullptr;
            l2 = l2 ? l2-&amp;gt;next : nullptr;
        }
        return dummy-&amp;gt;next;
    }
};
链接：https://leetcode.cn/problems/add-two-numbers/solutions/2327028/python3javacgo-yi-ti-yi-jie-mo-ni-jian-j-qdpm/
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;判断直接用&lt;code&gt;while (l1 || l2 || carry)&lt;/code&gt;来判断，条件清晰，使用carry来保存是否进位，比我的直接加的方法更好，注意辅助变量的使用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l1 ? l1-&amp;gt;val : 0&lt;/code&gt;等，注意&lt;code&gt;nullptr&lt;/code&gt;也可以表示false。&lt;/li&gt;
&lt;li&gt;使用dummy来表示第一个链表之前的链表，让逻辑更统一而无需特判。&lt;/li&gt;
&lt;li&gt;直接用新链表存储，避免了链表长度相关的影响。&lt;/li&gt;
&lt;/ol&gt;
">leetcode [2] 两数相加</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/nYAc4azQW/"" data-c="
          &lt;p&gt;上一周主要是考科二，准备回学校，写了下迎新小游戏。还放松（白兰）了几天。到学校要好好学习了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;科二和六级通过：六级能通过还是比较出乎意料的，本来按照考完对的答案来看似乎已经没救了，其实也差不多，这个听力真的太差了，要不是阅读的分数还好，早就不合格了。不过值得庆幸的是，缺点还是比较明确的，以后可以在这方面上多加训练。也要全民的背单词等，否则分数和水平还是不能再往上提高一个档次。这两个考试给我的最大的感受就是不要半场开香槟，永远不要骄傲自满，自己在大多数时候做的还远远不够。&lt;/li&gt;
&lt;li&gt;写迎新小游戏。小游戏的基本框架搭起来太方便了，基本的组件只需要cv就可以了。业务的逻辑也还是挺简单的。不过时间好像也没有那么紧，下次还是做得再尽量完美一点。这给我的启示是代码还是要多打多写，写的多了很多技术就能理解的更加好了。还有就是对nginx还不是很了解，导致设计api的时候名字并不是很合理，最后部署的时候还需要根据每个接口的名字来特判，以后写的时候需要注意api的命名规范。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;暴露给外部的供公共调用的api和仅限项目中前端调用的api需要区别吗？api包是否就是仅储存前者的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下周规划：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据结构学习：学到70把，但是要敲一敲代码了，还有笔记也要整理一下。&lt;/li&gt;
&lt;li&gt;微服务学习：把黑马的工程从头到尾再复习一遍。至es。把各技术栈写一个demo练练手。&lt;/li&gt;
&lt;li&gt;计算机网络学习：20集。&lt;/li&gt;
&lt;li&gt;go学习：再复习一下gorm和gin。&lt;/li&gt;
&lt;/ol&gt;
">8.27 周报</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/-Y3aBUN8b/"" data-c="
          &lt;p&gt;已经两周没写了，再不写就去跟大一的一块儿军训吧55555。这两周有一说一，有点小摆，感觉干的事不是很多。主要是把甜梨村完结了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完结天理村。大体都完成了，最后用了logstash来实现es和mysql同步，删除自己写了一个接口用反射来删除，有些侵入性，但是也勉强能接受吧。后续学一学flink，应该会更优雅一些。或者直接不做删除，用软删除，应该也可以解决这个问题。canal太难用了，也可能是我的方式不对？感觉学习新技术的能力还是不太行，需要提高。还有一大问题是关于缓存，不知道怎么样优雅的解决缓存中的部分数据过期的问题，现在能想到的一种方法是用mq，但是好像有些大炮打蚊子了，而且不够优雅，再想一想吧。日常有很多小bug，需要经常修复。对于linux还不是很熟悉，想做到自动部署，但是发现还有点麻烦而且效果不好。需要再多了解一下linux的进程相关的。&lt;/li&gt;
&lt;li&gt;改进bot：加了点小功能，发现也就两个月以前自己的代码就真的屎。顺便稍微了解了一下无头浏览器，做了一个类似爬虫的东西来搞oj数据。&lt;/li&gt;
&lt;li&gt;练车：小有进步，希望周四能过。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;怎么样去优雅的解决缓存的部分数据过期的问题。&lt;/li&gt;
&lt;li&gt;实现es和mysql数据同步的优雅方式。&lt;/li&gt;
&lt;li&gt;stop.sh 脚本为什么会出问题，无法杀死进程。&lt;/li&gt;
&lt;li&gt;为什么无头浏览器会出各种奇怪问题但是有时候自己又好了，看起来像是玄学问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下周规划：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过科目二。&lt;/li&gt;
&lt;li&gt;准备回家的东西。&lt;/li&gt;
&lt;li&gt;完成迎新游戏。&lt;/li&gt;
&lt;li&gt;学习go的分布式框架，复习gorm等，写项目。&lt;/li&gt;
&lt;/ol&gt;
">8.20 周报</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/hzemYGut9/"" data-c="
          &lt;p&gt;这一周主要是写项目吧，写115的项目。时间利用的应该还算可以，然后也学到了不少。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;天理村：开始写天理村的项目，写了一周，目前处于写了登录和大多数私聊的进度。这个项目带来的收获主要是团队协作上的。对于一些问题其实还不是很明白怎么处理，比如同时需要一个工具类的时候怎么写，谁来写之类的，而且cr做的确实有点少了，基本能顾住自己已经不错了。到是会开会来讨论很多方案，讨论的氛围也还不错。在这个过程中也大概学了学spring cache的基本使用，体验还是很不错的，尤其是用cache service这种方式感觉很舒服。对于有些场景下的缓存使用还不是很熟练，感觉对redis数据结构有些还不是很了解。不过整体下来感觉还好，开发过之前的项目后对很多场景的处理就得心应手多了。&lt;/li&gt;
&lt;li&gt;大致看了看es的查找。感觉es还是很方便的，期待下周去实际使用测试一下。&lt;/li&gt;
&lt;li&gt;练车：痛苦&lt;/li&gt;
&lt;li&gt;处理科协的事&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主要是团队协作方面的问题，感觉对怎么处理大家都要使用的资源的冲突还不是很熟练，比如git的冲突，还有工具类等。&lt;/li&gt;
&lt;li&gt;对于如何优雅的缓存，很多场景下还没有找到很合适的解决方案。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下周计划：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;天理村写完。&lt;/li&gt;
&lt;li&gt;学习hertz，gorm和ketex。&lt;/li&gt;
&lt;li&gt;处理科协事务。&lt;/li&gt;
&lt;li&gt;练车。&lt;/li&gt;
&lt;/ol&gt;
">8.6 周报</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/J_HGEyEql/"" data-c="
          &lt;p&gt;这一周基本就是写接口，策划科协的事务和搞了一点es。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写项目：现在深刻的意识到了产品的重要性，对于开发而言产品这样的角色太关键了。因为没有产品，需求不明确，开发的大量时间浪费在了猜测甲方需求等上面，前端还需要自己做页面，任何事情都要自己策划安排。不得不说是对综合能力的一个考验。周三和对接的老师开了一个会，稍微理解了一些抽象需求。这周尝试了一下阿里的easyexcel框架来处理excel，还是挺方便的，顺便也试了一下mp的批量插入，之前由于插入的问题搞出了100s相应的逆天接口。然而依然存在一些问题，最大的问题就是设计到多个模块的没有继承关系的po时应该怎么去写各种各样的param和res，这是一个海量的工作量。感觉可能需要什么设计模式，可是就自己所学的好像并不知道应该怎么办。&lt;/li&gt;
&lt;li&gt;学习es：照着黑马的课程配，居然在用docker的情况下因为环境耽误了好几天，这是几乎不能容忍的。主要原因是因为被8默认开启的xpack折磨的焦头烂额，而且还有了奇怪的关于数据卷的挂载的问题。以后可以考虑，一，教程等看好版本，对于出现的问题一定要给出详细确定的信息来检索，尽量使用英文。二，要提高一下自己看doc看官网配置，debug的技术。否则看博客永远都是第二手的信息而出现了从未遇到的问题或者找不到博客的问题的时候就容易不知道如何处理。&lt;/li&gt;
&lt;li&gt;科协的各种事情：写计算机通识的ppt，策划迎新游戏，oj思考题和上线oj等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在实体类很多而且没有继承关系的时候应该怎么样来处理对于不同接口会产生海量param和res问题。&lt;/li&gt;
&lt;li&gt;为什么会出现文件夹有777权限但是docker挂载的config目录依然无法写的问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下周规划：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;策划迎新游戏的剧情和内容。&lt;/li&gt;
&lt;li&gt;写咸鱼项目。&lt;/li&gt;
&lt;li&gt;写光伏发电项目。&lt;/li&gt;
&lt;li&gt;学es（学到足够开发使用，战线不要拖的太长了）&lt;/li&gt;
&lt;li&gt;处理科协的事务（贯穿始终）&lt;/li&gt;
&lt;/ol&gt;
">7.31 周报</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/g-urFbquo/"" data-c="
          &lt;p&gt;这一周总体来说，前三四天效率可以，后三天各种情况加摆烂。。。周五，没什么事，但好像也没干啥，可能写了点代码吧。周六一天，同学聚会。周日，头晕难受，g。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数据结构学习：学到了二叉树的二叉排序树。但这周更是风略一般的看完了课，首先是跟原先的计划少了8节，而且效果极差。在二叉的前中后遍历哪里感觉就没有怎么听懂。总的来说，这一块儿是需要停下来好好复习一下捋一捋了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分布式学习。效果还好，但还是没听完，差了五节吧。主要学了学mq和一点es。感觉es确实是需要好好学的，而且这次的项目也需要。实践还是没有，这两周至少es要实践一下了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写项目。上一周主要把管理的接口写了写，对于开发中的一些问题，比如分级鉴权，还有之前的登录注册流程之类的，是要更熟练一点了，毕竟也算是第一次实操。还是存在一些不足的，比如密码直接明文传递（，这个之后肯定是要改一下的。还有一个问题是在用注解来分级鉴权是有一个因为数组而闹出来的问题，一直不知道怎么解决。这暴漏了两个问题。一是当时解决问题太不积极了，本来还是比较好解决的问题，浪费了好几天，今天才搞明白。二是java基础在有些地方还是不扎实。比如final修饰的int[]的相关知识。这在开发中浪费了大量时间，所以说基础一定要打牢了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;学习加密相关。大致的开发常用的哈希函数和加密方法了解了一下，其实帮助还是挺大的，因为之前对这些都一知半解，讲jwt的时候也了解的不是特别清楚。这次整明白了，对以后的开发运用有很大的帮助。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在java中有没有能实现常量数组的方法。像开发中想向一个注解中传一个数组有什么方式可以解决呢。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下周规划：&lt;/p&gt;
&lt;p&gt;这两周太忙了。如果说整体的规划就是安排8月的讲座，做ppt。策划迎新活动，交策划书。写项目（光伏发电+115）。至于学习任务先不布置了，有时间的话尽量学一下es吧。然后复习一下前边所学的。&lt;/p&gt;
">7.23 周报</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/XyAzdNPN2/"" data-c="
          &lt;p&gt;这一周还是很充实的，大致按照之前的计划在学习和完成任务。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;学习数据结构。按照上周的计划学习到了栈。在理解上整体还可以，可能一是老师讲的不错，而是在使用了这么多既成的数据结构后再真正学习就好理解很多。不过实践太少了，实际上代码敲得太少了，仅仅只是听懂而已。其实感觉效率还不是很高，不知道是因为有些代码的任务还是什么，感觉听完之后没干什么一天就过去了。一是提高效率，还是要打一打代码。二是这周任务也可以适当少一点，因为这个问题很普遍，包括学习分布式和计网都有这个问题。实践太少了。&lt;/li&gt;
&lt;li&gt;学习分布式。只能说看了一遍eureka，nacos等，这次看docker倒是感觉理解稍微容易一点也多了一点。可能因为实践的多把。其实这次学习一个新的技术感觉理解起来好多了，感觉随着实际写代码变多，理解起来也越容易一点，果然还是需要实践出真知的，这在这星期写项目的时候体会尤其深刻。学习这个的问题一样：没有实际上手敲，有点过于追求速度了。不过感觉也还好，可以后来做一个小demo来复习一下。&lt;/li&gt;
&lt;li&gt;学习计算机网络。看了20集，没达到原定的25集目标。感觉后面时间不是很多（也可以说是今天摸鱼没听课。学习的主要是计算机网络的概况和最底下的两层，物理层和链路层。怎么说，感觉这个还是没有上面的几层那么有意思，不过也还可以。关于计网的很多知识可以和现实联系起来。不过这一遍可能也就是听个乐了，做题可能不会怎么有时间做了。&lt;/li&gt;
&lt;li&gt;开发海上光伏平台项目。这个给我的启示应该是最多的，毕竟学了也算不少，这是第一次实际去实际的开发项目。遇到了不少问题，这周想的很多问题也都与它有关。开发这个的过程让我实实在在的明白了代码架构的重要。面对着如果设计不好可能会产生无数屎一样的代码，我就必须去沉下来思考，这些代码可以复用吗？这个方法应该怎么封装，封装到那个模块儿？pojo应该怎么写？写的时候需要什么设计模式吗？需要继承吗？尤其是在写阈值pojo类的时候，用到了继承来降低了层级和代码量，相较组合而言。这就是一个组合和继承怎么选择的比较好的例子。关于线程之类的也思考的更多了，同时由于开发的有ws系列的接口，所以就会较http而言会思考时间尺度长更长的问题，反过来也会让我用这种思维来思考一些之前未曾想过的http的问题，比如springmvc处理http请求的方式等。这些都是在实际开发中学到的。我觉得更多的还是开发能力的提升。知道了这个功能应该怎么实现，去思考该不该用缓存，用缓存要怎么用。比如用到了redis的list，以一种很优雅的方式解决了近期6条数据的缓存。同时也经历了第一次前后端对线，对开发流程稍微了解一点了，并且对于如何去沟通，如何讨论数据传递的格式有了更多的了解。&lt;/li&gt;
&lt;li&gt;讲websocket。讲得感觉太快了，自己听回放不忍直视的感觉，希望下次可以讲得更稳一点，思路明确，更有逻辑一点。&lt;/li&gt;
&lt;li&gt;搞一堆杂七杂八的事。科协和组织聚餐。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;springboot中怎么对于每一个连接都维护一个定时器？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;springboot是怎么处理同时的多个http请求的呢？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;反思：&lt;/p&gt;
&lt;p&gt;主要是两点：提高效率和多多练习。&lt;/p&gt;
&lt;p&gt;下周规划：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据结构学习（王道p31-p60）&lt;/li&gt;
&lt;li&gt;分布式学习（黑马程序员p61-p100）&lt;/li&gt;
&lt;li&gt;计算机网络学习（p20-p40）&lt;/li&gt;
&lt;li&gt;写项目，应该要开始写管理的借口了&lt;/li&gt;
&lt;li&gt;学习加密相关内容，讲课。&lt;/li&gt;
&lt;/ol&gt;
">7.16 周报</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/Ku-6gg3bc/"" data-c="
          &lt;p&gt;已经快半个月没有更新周报了，之前因为一直在考试之类的一直推辞，没有记。不是一个好习惯，确实应该不止学习，大大小小的事都记录一下，总结一下。这算是上一周的总结，但也能说是上半个月的总结吧。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;复习和考试。对于这个环节，整体而言还好。投入相对较大精力复习的大物高数cpp在期末考试都有了相对不错的成绩。这种复习当时还是可以的。但前提是，这一门课对于你来说并非很紧要，也不是考研必修等，比如大物。在这种程度上cpp平时还是不应该如此摆烂的。下学期还是要注意，值得学的课一定不能摆烂。&lt;/li&gt;
&lt;li&gt;搞科协的各种事。有一说一，这还是第一次作为负责人去操办这么多事吧。感觉其实还是有不少问题的。在商讨支付方案时的brain storm还不错，讨论的也还可以，但是最后有点脱离实际，而且感觉大家并不是很重视，参与度还不够。而且之前的方案太容易的被推翻。现在越来越感觉粗暴的解决某种问题恰巧自身能力不足的体现。没有足够的做judgement的能力而只能选择一刀切的方法。首先制定方案的时候聪明一点，想的多一点，不能拍脑袋，想的全面一点。这样在实际执行的时候也会好执行一点。至于其他的感觉还好，还好同学都比较配合人也比较好。最近也在帮忙组织初中的聚餐，感觉其实只要专注一点，效率高一点，即使事多也还好。&lt;/li&gt;
&lt;li&gt;搞敏感词匹配。其实感觉写的过程整体还比较顺利。开发tg bot等的速度也很快，对go web的开发流程慢慢有了一些了解，对于有web基础的人来说确实很好上手。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;学reids有点快，对redis整体不管是知识点还是应用都不是很熟练。&lt;/li&gt;
&lt;li&gt;同样的问题，go的基础也不是很扎实。&lt;/li&gt;
&lt;li&gt;对mybatis配置有些遗忘。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下周规划：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;servlet系列的课程看完。&lt;/li&gt;
&lt;li&gt;redis的序列化等复习，把redis基础和整合再过一遍。&lt;/li&gt;
&lt;li&gt;微服务学习（黑马程序员docker compose学完。）&lt;/li&gt;
&lt;li&gt;go基础学习。&lt;/li&gt;
&lt;li&gt;数据结构学习（王道p7-p31）&lt;/li&gt;
&lt;li&gt;计算机网络学习（胡科大教书匠p25前）&lt;/li&gt;
&lt;/ol&gt;
">7.7 周报</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/xaoCvNgGP/"" data-c="
          &lt;p&gt;这一周发了点烧，有两天没能学习，文化课和编程都学了点。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;物理复习。把大致的知识点看了看，但是题没有做几道，下周要把作业的题通一遍。总体来说还好。&lt;/li&gt;
&lt;li&gt;高数复习。基本都是在老师那里复习的，做了一套卷子。只能说感觉还好把。难度应该还行。但绝对不能放松，还有很多题是没有看的，多元微积分因为期中考过所以第一遍复习的时候还没有系统复习。还有很多题需要练。问题最大的应该还是级数和微分方程，主要是级数中的幂级数等。对，多元函数极值也是一个问题。这些下周就要解决了，下周把物理和高数的题集中刷一刷。&lt;/li&gt;
&lt;li&gt;用go重写qqbot。本来想搞微信，但是那个微信平台的bot搞起来有点麻烦，所以还是先用之前的配置重写qq的bot了。体验有两点，go是真的快和写项目的时候最大的问题应该还是解决一个问题的思路，在重写的时候经常要实现之前的功能快多了，不仅仅是语言本身的简洁，感觉更是思路的明确带来的效率提升。所以以后开发的时候一定要注意明确思路，先想好问题的解决方式。平时重点锻炼的也应该是这个。后期后端考核也可以考虑增加这个方面的考核比重。但是如何考量是一个问题。写的时候发现自己对go还是非常的生疏。很多偏基础的部分都不是很了解。感觉很多还是对于指针的使用不是很熟悉吧。在java中指针这个东西也被淡化很多了。总体上是边写边查，效率和解决问题的能力尚可。&lt;/li&gt;
&lt;li&gt;学习websocket。学习了一点ws的基础原理和简单应用，能做到基本的收发消息等。等前端也好了可以考虑做一个小群聊聊天室练练。&lt;/li&gt;
&lt;li&gt;使用slf4j略微改善了bot。之前的日志全都靠sout，日期还要自己设定时区并获取和打印，很笨。用slf4j让日志稍微改进了一点。不过更深一点的log4j和logback还没使用。现在也只是用logback的默认设置，不过目前看应该是可以满足需求了。不过是有一个小问题，就是日志应该记录到什么程度，应该在哪里设置日志打印呢。&lt;/li&gt;
&lt;li&gt;接入腾讯云api，实现发短信。不得不说，妮果搞得这一堆东西是真恶心。在腾讯云上申请域名 备案网站 申请模板一堆东西每一个省心过。各种奇葩要求和煞笔限制。除了申请的过程让人感觉不适，接入api还是很顺利的，比我想象的要简单。&lt;/li&gt;
&lt;li&gt;使用smtp发送邮箱。不得不说springboot真的强大，封装好的mail starter让发邮件变得无比简单。本来还想自己搭一个smtp服务，不过好像有点麻烦，再研究研究。&lt;/li&gt;
&lt;li&gt;考六级。听力惨败，不忍直视，教训深刻。阅读还好，但是后面的大阅读依然很不应该的错了三个。阅读能力还是要提高，较难一点的题还是要练的。阅读还是要再练一练。然后翻译的时候很多词都想不起来了，应用能力太低，对很多词还是见的少用的少。词汇整体水平也不高，需要再加大词汇量和阅读量。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;项目中日志需要打印到什么程度呢。&lt;/li&gt;
&lt;li&gt;如何实现go读取配置文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下周规划：&lt;/p&gt;
&lt;p&gt;整体就是专心复习期末。&lt;/p&gt;
&lt;p&gt;bottom-line：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;高数所有复习题写完，卷子写完，所有知识点再过一遍。重点过一下后面两章，一些小点也要注意。多元函数极值等。复习题一天半之内再写一遍。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大物的课本习题过一遍，知识点再过一遍。每天至少5章。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;计算机类的学习根据兴趣自己学。&lt;/p&gt;
">6.18 周报</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/QvKR0-wLd/"" data-c="
          &lt;p&gt;此帖记录一些随想，没有特定主题。&lt;br&gt;
【2023-6-18】昨天的六级考的有点久违的高考的感觉。总是有这种自以为还可以很简单但是却最后被狠狠打脸的经历。高考已经是一个非常大的教训了，必须要警钟长鸣。应当意识到，我不是什么天才，也没有什么特别的运气，想要的东西至少付出很大的努力才可能得到。不要有投机取巧的幻想，踏踏实实的学习。&lt;/p&gt;
">【置顶】Some Ideas</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/6MiJWp4oq/"" data-c="
          &lt;p&gt;WebSocket简介与java实现&lt;/p&gt;
&lt;h1 id=&#34;http的不便&#34;&gt;http的不便&lt;/h1&gt;
&lt;p&gt;问题：我们经常会有前后端实时双向传递信息的需求，在需要实现实时信息传递的情境下，采用http应该怎么做呢？&lt;/p&gt;
&lt;p&gt;方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前端ajax轮询&lt;/li&gt;
&lt;li&gt;http长轮询（http long poll）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两种方法理论都可以实现，但却都不是那么方便。&lt;/p&gt;
&lt;p&gt;首先来说说ajax轮询：&lt;/p&gt;
&lt;p&gt;ajax轮询 的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。&lt;/p&gt;
&lt;p&gt;接着看看http长轮询：&lt;/p&gt;
&lt;p&gt;long poll 其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。&lt;/p&gt;
&lt;p&gt;从上面两种方式能看出来，这两种方式都是不断地建立http连接并等待服务端处理，体现了http协议的一个特点&lt;strong&gt;被动性&lt;/strong&gt; 。即服务端无法主动联系客户端，请求只能由服务端发起，后端如果有什么消息更新想告诉前端，是不方便的。&lt;/p&gt;
&lt;p&gt;再来说说上面两种解决方案的问题所在：&lt;/p&gt;
&lt;p&gt;ajax轮询 需要服务器有很快的处理速度和资源。&lt;/p&gt;
&lt;p&gt;long poll 需要有很高的并发，也就是说同时接待客户的能力。&lt;/p&gt;
&lt;p&gt;这就对服务器性能提出较高的要求，而且这两种实现方式都是非常消耗服务器资源的，例如对于ajax轮询来说，要不断地建立和断开http连接，很多时候还有查询数据库的需要，如果有https还需要校验证书，这都大大增加了服务器的性能压力。而且，http也是一种&lt;strong&gt;无状态&lt;/strong&gt;的协议，无法记住之前的信息，这对于某些情境下也不是很方便，需要cookie或者session来处理。综上所述，HTTP 基于简单的&lt;strong&gt;请求和响应模型&lt;/strong&gt;工作，这会产生很大的**延迟，**由于http在当前情景下的诸多不便，我们需要一些更加优雅的处理方式。&lt;/p&gt;
&lt;h1 id=&#34;websocket&#34;&gt;Websocket&lt;/h1&gt;
&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器&lt;strong&gt;全双工&lt;/strong&gt; （full-duplex）通信，即允许服务器主动发送信息给客户端。因此，在WebSocket中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输，客户端和服务器之间的数据交换变得更加简单。&lt;/p&gt;
&lt;p&gt;WebSocket的握手连接基于http，但是在连接后就跟http没有关系，用封装好的基于tcp的方式来通信。&lt;/p&gt;
&lt;p&gt;WebSocket协议不受同源策略影响。&lt;/p&gt;
&lt;p&gt;这些特点让上述的问题有了一个比较好的解决方案。因为是全双工通信，服务端可以随时向客户端发信息，这使得后端如果有什么新的消息需要向前端汇报，前端可以第一时间接受，而且在后台占用的资源相较上边的两种方式而言低很多，处理速度快了很多。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://silentiris.github.io/post-images/1689659631020.PNG&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;建立连接&#34;&gt;建立连接&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;第一步：客户端向服务端通过握手协议建立连接&lt;/li&gt;
&lt;li&gt;第二步：服务端向客户端回应握手请求&lt;/li&gt;
&lt;li&gt;第三步：服务端开始向客户端推送消息&lt;/li&gt;
&lt;li&gt;第四步：客户端可以主动断开websocket连接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单来说，ws首先会利用http的握手机制来进行连接。&lt;/p&gt;
&lt;h3 id=&#34;客户端申请协议升级&#34;&gt;客户端：申请协议升级&lt;/h3&gt;
&lt;p&gt;当客户端想要使用 WebSocket 协议与服务端进行通信时, 首先需要确定服务端是否支持 WebSocket 协议, 因此 WebSocket 协议的第一步是进行握手, WebSocket 握手采用 HTTP Upgrade 机制, 客户端可以发送如下所示的结构发起握手 (请注意 WebSocket 握手只允许使用 HTTP GET 方法)。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-HTTP&#34;&gt; GET / HTTP/1.1
 Host: localhost:8080
 Origin: http://127.0.0.1:3000
 Connection: Upgrade
 Upgrade: websocket、
 Sec-WebSocket-Version: 13
 Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw==
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重点请求首部意义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Connection: Upgrade&lt;/code&gt;：表示要升级协议&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Upgrade: websocket&lt;/code&gt;：表示要升级到websocket协议。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sec-WebSocket-Version: 13&lt;/code&gt;：表示websocket的版本。如果服务端不支持该版本，需要返回一个&lt;code&gt;Sec-WebSocket-Version&lt;/code&gt;header，里面包含服务端支持的版本号。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sec-WebSocket-Key&lt;/code&gt;：与后面服务端响应首部的&lt;code&gt;Sec-WebSocket-Accept&lt;/code&gt;是配套的，提供基本的防护，比如恶意的连接，或者无意的连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，上面请求省略了部分非重点请求首部。由于是标准的HTTP请求，类似Host、Origin、Cookie等请求首部会照常发送。在握手阶段，可以通过相关请求首部进行 安全限制、权限校验等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;服务端响应协议升级&#34;&gt;&lt;strong&gt;服务端：响应协议升级&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在 HTTP Header 中设置 Upgrade 字段, 其字段值为 websocket, 并在 Connection 字段指示 Upgrade, 服务端若支持 WebSocket 协议, 并同意握手, 可以返回如下所示的结构:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-HTTP&#34;&gt; HTTP/1.1 101 Switching Protocols
 Connection:Upgrade
 Upgrade: websocket
 Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;状态代码&lt;code&gt;101&lt;/code&gt;表示协议切换。到此完成协议升级，后续的数据交互都按照新的协议来。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：每个header都以&lt;code&gt;\r\n&lt;/code&gt;结尾，并且最后一行加上一个额外的空行&lt;code&gt;\r\n&lt;/code&gt;。此外，服务端回应的HTTP状态码只能在握手阶段使用。过了握手阶段后，就只能采用特定的错误码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;sec-websocket-accept的计算&#34;&gt;&lt;strong&gt;Sec-WebSocket-Accept的计算&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Sec-WebSocket-Accept&lt;/code&gt;根据客户端请求首部的&lt;code&gt;Sec-WebSocket-Key&lt;/code&gt;计算出来。&lt;/p&gt;
&lt;p&gt;计算公式为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将&lt;code&gt;Sec-WebSocket-Key&lt;/code&gt;跟&lt;code&gt;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&lt;/code&gt;拼接。&lt;/li&gt;
&lt;li&gt;通过SHA1计算出摘要，并转成base64字符串。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;伪代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt; &amp;gt;toBase64( sha1( Sec-WebSocket-Key + 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 )  )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;验证下前面的返回结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt; const crypto = require(&#39;crypto&#39;);
 const magic = &#39;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#39;;
 const secWebSocketKey = &#39;w4v7O6xFTi36lq3RNcgctw==&#39;;
 
 let secWebSocketAccept = crypto.createHash(&#39;sha1&#39;)
     .update(secWebSocketKey + magic)
     .digest(&#39;base64&#39;);
 
 console.log(secWebSocketAccept);
 // Oy4NRAQ13jhfONC7bP8dTKb4PTU=
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;状态码&#34;&gt;&lt;strong&gt;状态码&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;连接成功状态码&lt;/p&gt;
&lt;p&gt;101：HTTP协议切换为WebSocket协议。&lt;/p&gt;
&lt;p&gt;连接关闭状态码&lt;/p&gt;
&lt;p&gt;1000：正常断开连接。&lt;/p&gt;
&lt;p&gt;1001：服务器断开连接。&lt;/p&gt;
&lt;p&gt;1002：websocket协议错误。&lt;/p&gt;
&lt;p&gt;1003：客户端接受了不支持数据格式（只允许接受文本消息，不允许接受二进制数据，是客户端限制不接受二进制数据，而不是websocket协议不支持二进制数据）。&lt;/p&gt;
&lt;p&gt;1006：异常关闭。&lt;/p&gt;
&lt;p&gt;1007：客户端接受了无效数据格式（文本消息编码不是utf-8）。&lt;/p&gt;
&lt;p&gt;1009：传输数据量过大。&lt;/p&gt;
&lt;p&gt;1010：客户端终止连接。&lt;/p&gt;
&lt;p&gt;1011：服务器终止连接。&lt;/p&gt;
&lt;p&gt;1012：服务端正在重新启动。&lt;/p&gt;
&lt;p&gt;1013：服务端临时终止。&lt;/p&gt;
&lt;p&gt;1014：通过网关或代理请求服务器，服务器无法及时响应。&lt;/p&gt;
&lt;p&gt;1015：TLS握手失败。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;连接关闭状态码是WebSocket对象的onclose属性返回的。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;心跳重连&#34;&gt;&lt;strong&gt;心跳重连&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;和真实的心跳一样，隔一段时间发一个小数据包，类似于ping pong！，用来判断连接是否还存在。&lt;/p&gt;
&lt;p&gt;建议由客户端实现&lt;/p&gt;
&lt;h1 id=&#34;websocket的java实现&#34;&gt;&lt;strong&gt;WebSocket的Java实现&lt;/strong&gt;&lt;/h1&gt;
&lt;h2 id=&#34;依赖&#34;&gt;&lt;strong&gt;依赖&lt;/strong&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-XML&#34;&gt;         &amp;lt;dependency&amp;gt;
             &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
             &amp;lt;artifactId&amp;gt;spring-boot-starter-websocket&amp;lt;/artifactId&amp;gt;
         &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;websocketconfig&#34;&gt;&lt;strong&gt;WebSocketConfig&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;config&lt;/code&gt;包新建&lt;code&gt;WebSocketConfig.java&lt;/code&gt;，注入ServerEndpointExporter，这个bean会自动注册使用了@ServerEndpoint注解声明的Websocket endpoint。（要注意，如果使用独立的servlet容器，而不是直接使用springboot的内置容器，就不要注入ServerEndpointExporter，因为它将由容器自己提供和管理。）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt; @Configuration
 public class WebSocketConfig {
     @Bean
     public ServerEndpointExporter serverEndpointExporter() {
         return new ServerEndpointExporter();
     }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;websocketutil&#34;&gt;WebsocketUtil&lt;/h2&gt;
&lt;p&gt;加入&lt;code&gt;@ServerEndpoint&lt;/code&gt;和&lt;code&gt;@Component&lt;/code&gt;注解。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@ServerEndpoint&lt;/code&gt; 注解是一个类层次的注解，它的功能主要是将目前的类定义成一个websocket服务器端, 注解的值将被用于监听用户连接的终端访问URL地址,客户端可以通过这个URL来连接到WebSocket服务器端。&lt;/p&gt;
&lt;p&gt;加入&lt;code&gt;@Component&lt;/code&gt;使其可以被spring容器扫描到。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;package com.sipc.websocketdemo.websocketserver;

import jakarta.websocket.*;
import jakarta.websocket.server.PathParam;
import jakarta.websocket.server.ServerEndpoint;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@ServerEndpoint(&amp;quot;/ws/{token}&amp;quot;)
@Component
public class WebSocketUtil {
    private static int onlineCount = 0;//在线人数
    private static ConcurrentHashMap&amp;lt;String, WebSocketUtil&amp;gt; webSocketMap = new ConcurrentHashMap&amp;lt;&amp;gt;();//在线用户集合
    private Session session;//与某个客户端的连接会话
    private String currentUser;

    /**
     * 获取当前所有在线用户名
     */
    public static void allCurrentOnline() {
        for (Map.Entry&amp;lt;String, WebSocketUtil&amp;gt; item : webSocketMap.entrySet()) {
            System.out.println(item.getKey());
        }
    }

    /**
     * 发送给指定用户消息
     */
    public static void sendMessageTo(String message, String token) {
        WebSocketUtil item = webSocketMap.get(token);
        System.out.println(&amp;quot;to&amp;quot;+token+&amp;quot;:&amp;quot; + message);
        try {
            item.session.getBasicRemote().sendText(message);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * 群发自定义消息
     */
    public static void sendInfo(String message) {
        System.out.println(message);
        for (Map.Entry&amp;lt;String, WebSocketUtil&amp;gt; item : webSocketMap.entrySet()) {
            item.getValue().sendMessage(message);
        }
    }

    public static synchronized int getOnlineCount() {
        return onlineCount;
    }

    public static synchronized void addOnlineCount() {
        WebSocketUtil.onlineCount++;
    }

    public static synchronized void subOnlineCount() {
        WebSocketUtil.onlineCount--;
    }

    @OnOpen         //有新连接时触发
    public void onOpen(@PathParam(&amp;quot;token&amp;quot;) String token, Session session) {
        this.currentUser = token;
        this.session = session;
        webSocketMap.put(token, this);
        addOnlineCount();
        System.out.println(&amp;quot;有新连接&amp;quot; + currentUser + &amp;quot;加入！当前在线人数为&amp;quot; + getOnlineCount());
    }

    @OnClose        //有连接关闭时触发 
    public void onClose() {
        String closeUser = this.currentUser;
        webSocketMap.remove(this.currentUser);
        subOnlineCount();
        System.out.println(closeUser + &amp;quot;连接关闭！当前在线人数为&amp;quot; + getOnlineCount());
    }

    @OnMessage        //有连接传来的新消息时触发
    public void onMessage(String message, Session session) {
        System.out.println(&amp;quot;来自客户端&amp;quot;+currentUser+&amp;quot;的消息：&amp;quot; + message);
        for (Map.Entry&amp;lt;String, WebSocketUtil&amp;gt; item : webSocketMap.entrySet()) {
            if (item.getValue() == this) {
                sendMessageTo(&amp;quot;cnm&amp;quot;, this.currentUser);
                continue;
            }
            item.getValue().sendMessage(message);
        }
    }

    @OnError        
    public void onError(Session session, Throwable throwable) {
        System.out.println(&amp;quot;发生错误！&amp;quot;);
        throwable.printStackTrace();
    }
    /**
     * 给自己发送自己刚发的消息
     */
    public void sendMessage(String message) {
        try {
            this.session.getBasicRemote().sendText(message);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考:&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/chyingp/p/websocket-deep-in.html&lt;/p&gt;
&lt;p&gt;https://zhuanlan.zhihu.com/p/145628937&lt;/p&gt;
&lt;p&gt;https://sunyunqiang.com/blog/websocket_protocol_rfc6455/&lt;/p&gt;
">WebSocket简介与java 实现</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/W1-bMXR8Q/"" data-c="
          &lt;p&gt;这一周大概按照规划所说的主要复习六级和期末，但其实也搞了不少编程的（确实有意思，瘾犯了...&lt;/p&gt;
&lt;p&gt;在这一周里其实还是有很大问题，先总结一下干了什么吧：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每天一套英语六级。这个确实落实了，每天也都有听力。但其实落实的具体过程很不行。首先是跟高中一样的问题：太浮躁。做完对改完就想干其他事。最后实际上可能只是只是把词给记了记，最多看一下阅读。听力复听只有第一天落实了，而且效果一般。还有一个问题是听力总是不能集中，只有在非常集中的时候才可能能听明白一点，但总是没法一直保持注意力高度集中。最后导致听力非常拉跨。对于阅读来说，除了第一篇，正确率尚可，15选10基本能做到25分钟错1-2个，阅读15分钟1-2个。前面的选词很拉跨，每次基本都错五个，但还不是不能接受，占比低，用时较短。翻译现在用时太长了，很多固定的形式不知道怎么表达，作文还没有联系。总之，还有很多需要提高的。&lt;/li&gt;
&lt;li&gt;高数复习。这个得益于老师的良心复习计划和上课带着我们复习，推动的速度还挺快。但有一些记得很不牢靠，需要再做一做题。尤其是级数和微分方程。而且总的来说还是感觉水了点，效率有点低。尤其是对于级数的知识点的复习还有问题。考试前一周还需要再看一看。&lt;/li&gt;
&lt;li&gt;大物复习。也就周六周日复习了一下，而且时间很短。总的来说，虽然可以说完成了纸上写的目标，但是只是看了看基础知识点，把最基本的题做了做，还需要再复习一遍，把题再做一遍。目前存在的问题是不知道后面的磁和光要怎么复习了。再看一看同学的笔记之类的把。&lt;/li&gt;
&lt;li&gt;nginx配置。这周摸鱼的时候做的。但是其实还用了挺多时间。总的来说，折腾了半天，对nginx搞动静分离和反向代理有了一点认识吧，会一些基本的配置和软连接，对nginx的运作有了一些基本的了解。折腾了半天也勉强会配置一下https。不过最后还是nginx proxy manager了。&lt;/li&gt;
&lt;li&gt;每天看十页computer networing.其实有很大一部分时间都用在翻译和理解意思上，但是个人觉得这种方法还是可以的，而且书本身足够通俗易懂。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;怎么样可以保证一段时间的注意力高度集中。&lt;/li&gt;
&lt;li&gt;怎么尽可能的提高阅读速度同时还尽量保证捕获关键信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下周规划：&lt;/p&gt;
&lt;p&gt;总体是复习加代码，现在时间较为宽松，有了更多时间但一定要注意提高效率，有目的一点。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;高数复习完，复习题写完。&lt;/li&gt;
&lt;li&gt;英语5套六级题，保证阅读和听力的复听。&lt;/li&gt;
&lt;li&gt;物理至少复习到光学以前。&lt;/li&gt;
&lt;li&gt;使用go开发微信机器人。&lt;/li&gt;
&lt;/ol&gt;
">6.11 周报</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/1pZxBFCME/"" data-c="
          &lt;h1 id=&#34;code-server-简介&#34;&gt;code-server 简介&lt;/h1&gt;
&lt;p&gt;目前 &lt;em&gt;Coder Technologies Inc, an Austin TX company&lt;/em&gt; 公司开源了一个基于服务器端的 VScode -- code-server，只要服务器端配置好code-server，就可以在任何浏览器上使用VScode 。在code-server上可以自由的使用vscode中的插件，也可以快速的配置好一套云开发环境。&lt;/p&gt;
&lt;p&gt;下面来讲解一下code-server在linux上的下载与配置。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;主机环境：（linux系统均可）
debian11
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;下载&#34;&gt;下载&lt;/h1&gt;
&lt;h2 id=&#34;1-下载code-server的二进制文件&#34;&gt;1. 下载code-server的二进制文件&lt;/h2&gt;
&lt;p&gt;&lt;mark&gt;&lt;a href=&#34;https://github.com/coder/code-server&#34;&gt;code-server官方github地址&lt;/a&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;在release的asset中找到最新版本，此时是4.13.0&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://silentiris.github.io/post-images/image-20230604213416888.png&#34; alt=&#34;image-20230604213416888&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;根据自己的linux服务器架构选择对应的版本，可以用&lt;code&gt;arch&lt;/code&gt; 命令查看，例如我就是x86架构，应该选择amd64。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;root@vultr:~# arch
x86_64
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用wget来从github获取到压缩包&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# wget https://github.com/coder/code-server/releases/download/v4.13.0/code-server-4.13.0-linux-amd64.tar.gz
# ls
code-server-4.13.0-linux-amd64.tar.gz
//解压
# tar -zxvf code-server-4.13.0-linux-amd64.tar.gz
//此时就可以删除压缩包
# rm code-server-4.13.0-linux-amd64.tar.gz 
//给文件夹改名
# mv code-server-4.13.0-linux-amd64/ code-server

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;运行可执行文件&#34;&gt;运行可执行文件&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;//进入code-server的bin目录
# cd code-server/bin
# ls
code-server  //只有一个code-server的可执行文件
//执行code-server
# ./code-server
[2023-06-04T13:47:08.159Z] info  Wrote default config file to ~/.config/code-server/config.yaml
[2023-06-04T13:47:08.744Z] info  code-server 4.13.0 2798322b03e7f446f59c5142215c11711ed7a427
[2023-06-04T13:47:08.747Z] info  Using user-data-dir ~/.local/share/code-server
[2023-06-04T13:47:08.763Z] info  Using config file ~/.config/code-server/config.yaml
[2023-06-04T13:47:08.764Z] info  HTTP server listening on http://127.0.0.1:8080/
[2023-06-04T13:47:08.764Z] info    - Authentication is enabled
[2023-06-04T13:47:08.765Z] info      - Using password from ~/.config/code-server/config.yaml
[2023-06-04T13:47:08.766Z] info    - Not serving HTTPS
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时候还不能直接访问，因为开放连接的ip是&lt;code&gt;127.0.0.1&lt;/code&gt;，除了本机外无法访问。&lt;/p&gt;
&lt;h2 id=&#34;更改配置文件&#34;&gt;更改配置文件&lt;/h2&gt;
&lt;p&gt;可以去配置文件中修改，配置文件的路径是上面&lt;code&gt;[2023-06-04T13:47:08.763Z] info  Using config file ~/.config/code-server/config.yaml&lt;/code&gt;中的&lt;code&gt;~/.config/code-server/config.yaml&lt;/code&gt;，vim修改。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# vim ~/.config/code-server/config.yaml
bind-addr: 127.0.0.1:8080
auth: password
password: 25d2c03cc74d3e3f6c56499a
cert: false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bind-addr是你允许的访问的ip以及在那个端口开放，例如，如果想允许所有IP访问并开放8077端口，应该写&lt;code&gt;0.0.0.0:8077&lt;/code&gt;。同时需要开放服务器的8077端口，如果云服务器有防火墙还需要去云服务器控制台开放8077端口。&lt;/p&gt;
&lt;p&gt;password是指你的访问密码，最好设置的复杂一点。&lt;/p&gt;
&lt;p&gt;然后保存文件并退出。&lt;/p&gt;
&lt;h2 id=&#34;再次运行&#34;&gt;再次运行&lt;/h2&gt;
&lt;p&gt;再次&lt;code&gt;./code-server&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;root@vultr:~/code-server/bin# ./code-server
[2023-06-04T14:24:04.718Z] info  code-server 4.13.0 2798322b03e7f446f59c5142215c11711ed7a427
[2023-06-04T14:24:04.723Z] info  Using user-data-dir ~/.local/share/code-server
[2023-06-04T14:24:04.740Z] info  Using config file ~/.config/code-server/config.yaml
[2023-06-04T14:24:04.740Z] info  HTTP server listening on http://0.0.0.0:8077/
[2023-06-04T14:24:04.741Z] info    - Authentication is enabled
[2023-06-04T14:24:04.742Z] info      - Using password from ~/.config/code-server/config.yaml
[2023-06-04T14:24:04.742Z] info    - Not serving HTTPS
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时候code-server就启动成功了，可以去浏览器输入&amp;lt;你的ip&amp;gt;:8077访问code-server，例如：108.78.89.88:8077&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://silentiris.github.io/post-images/image-20230604222509505.png&#34; alt=&#34;image-20230604222509505&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;出现这个界面就成功了，输入刚刚的密码，进入。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://silentiris.github.io/post-images/image-20230604222828825.png&#34; alt=&#34;image-20230604222828825&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这和我们本地的vscode几乎一样的。&lt;/p&gt;
&lt;h2 id=&#34;安装插件&#34;&gt;安装插件&lt;/h2&gt;
&lt;p&gt;可以去插件市场搜索chinese插件，更换语言，并且下载一些自己需要的插件。有一些插件无法下载。我们可以从vscode扩展商店的网站上下载&lt;code&gt;.vsix&lt;/code&gt;文件来手动安装。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/VSCode&#34;&gt;微软插件市场&lt;/a&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://silentiris.github.io/post-images/image-20230604223222729.png&#34; alt=&#34;image-20230604223222729&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以在这里下载，然后通过sftp上传到服务器，在code-server的插件界面可以选择&lt;code&gt;.vsix&lt;/code&gt;文件安装拓展。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://silentiris.github.io/post-images/image-20230604223350938.png&#34; alt=&#34;image-20230604223350938&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;在screen中启动&#34;&gt;在screen中启动&lt;/h2&gt;
&lt;p&gt;目前这个code-server只存在于当前这个连接中，连接一旦断开就没有了。我们可以用screen，nohup或者tmux来让他在后台一直运行。&lt;/p&gt;
&lt;p&gt;例如screen：&lt;/p&gt;
&lt;p&gt;首先安装screen：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# apt install screen
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;开启一个新的screen(命名为&amp;quot;code-server&amp;quot;)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# screen -S &amp;quot;code-server&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在即使断开连接，code-server在后台也会一直运行。&lt;/p&gt;
&lt;p&gt;ps. 一些常见的screen命令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;screen -ls 显示进程列表
screen -r sid 恢复某个进程
screen -X -S sid quit 终止某个进程
screen -S my_screen_name 修改会话名称
ctrl+a d 离开当前进程
ctrl+a k 终止当前进程
&lt;/code&gt;&lt;/pre&gt;
">code-server安装及配置</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/NgW_kI9C8/"" data-c="
          &lt;p&gt;这一周可以说干了不少，但其实好像在学习方面的也不是很多，想一想具体干了什么的话。大概就是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;学前端的知识。html，css，js等仅仅只能说过了一遍，了解了大概语法，还有一些vue的基础，学到了element-ui，但依然也是最基本的。还没有看过前端项目的代码，希望去看的时候不要太吃力。&lt;/li&gt;
&lt;li&gt;用go语言去重构bot。这其实只是占用了很少时间，大概一个晚上的几个小时把。期间有很多问题，比如对象的反序列化。gin的基本使用等。对着cz的现成项目照猫画虎，基本了解了用gin实现go的基本逻辑。但是还要再熟练。值得注意的是，需要对go的闭包特性有更深的理解，多看一看代码，这是一个与java不一样的而且很灵活的特性。go需要学习的还有很多，继续努力。&lt;/li&gt;
&lt;li&gt;选购配件，组装服务器，内网穿透。这主要是三个过程。选购和组装基本是学长帮忙。自己在旁边看着也能学点什么吧。在搞frp的时候，又深深的感受到了计网知识贫瘠的痛苦。遇到问题找半天不知道怎么解决，对nginx完全不了解。对于交换机什么的也不知道怎么用。对域名的解析规则理解的不透彻，导致在配置子域名的时候经常有很窒息的操作。计算机网络还是要重点学习一下。对于配置code-server，clash和frp的过程可以写个博客记录一下。还有一点，安全意识过于薄弱。需要学习一下服务器的基本安全常识。&lt;/li&gt;
&lt;li&gt;搭博客。其实也并没有占用很长时间，用&lt;code&gt;gridea&lt;/code&gt;直接速成了。用了大概一个晚上把。解析子域名的时候还稍微卡了卡。希望以后能坚持写下去。周报也记录在上面。&lt;/li&gt;
&lt;li&gt;把redis看完。上周的redis还剩下集群和哨兵模式。这两块儿其实只能说看了看有个大概印象把。以后实际应用的时候再细学。&lt;br&gt;
上面差不多就是这周干的事了，现在总会有一种回首望过去，感觉好像也没干啥的感觉。这种感觉很不好，绝对不能发展成假学习的现象。要提高效率，并且有明确的目标，注意力需要再集中一点。不能太松散了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;产生的疑问：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;nginx是干什么的？什么原理？和frp的区别？frp的原理？&lt;/li&gt;
&lt;li&gt;闭包的意义？（对于编程思想而言。）java的闭包可以说是真正的闭包吗？和go或者js 的闭包有什么区别？&lt;/li&gt;
&lt;li&gt;服务器的安全都需要注意什么？怎么能尽量保证在开放公网端口的同时还有较高的安全性？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下一周的任务：&lt;br&gt;
整体上就是复习期末和备考六级。&lt;br&gt;
bottom-line：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;7套6级题，完整批改，听力复听，单词整理。&lt;/li&gt;
&lt;li&gt;高数复习：
&lt;ul&gt;
&lt;li&gt;级数复习，一天完成。&lt;/li&gt;
&lt;li&gt;微分方程复习，一天完成。&lt;/li&gt;
&lt;li&gt;所有复习题，一天完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;大物复习：
&lt;ul&gt;
&lt;li&gt;速度：半天一章，保持高效率。&lt;/li&gt;
&lt;li&gt;至少复习2章。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
">6.4 周报</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/r_SdW9GU2/"" data-c="
          &lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;在Java世界里面，面向对象还是主流思想，对于习惯了面向对象编程的开发者来说，抽象的概念并不陌生。面向对象编程是对数据进行抽象，而函数式编程是对行为进行抽象。现实世界中，数据和行为并存，程序也是如此，因此这两种编程方式我们都得学。&lt;/p&gt;
&lt;p&gt;这种新的抽象方式还有其他好处。很多人不总是在编写性能优先的代码，对于这些人来说，函数式编程带来的好处尤为明显。程序员能编写出更容易阅读的代码——这种代码更多地表达了业务逻辑，而不是从机制上如何实现。易读的代码也易于维护、更可靠、更不容易出错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;面向对象编程是&lt;mark&gt;对数据进行抽象&lt;/mark&gt;；函数式编程是&lt;mark&gt;对行为进行抽象&lt;/mark&gt;。&lt;br&gt;
核心思想: 使用不可变值和函数，函数对一个值进行处理，映射成另一个值。&lt;br&gt;
对核心类库的改进主要包括集合类的API和新引入的流Stream。流使程序员可以站在更高的抽象层次上对集合进行操作。&lt;/p&gt;
&lt;h1 id=&#34;lambda表达式&#34;&gt;lambda表达式&lt;/h1&gt;
&lt;p&gt;lambda表达式仅能放入如下代码: 预定义使用了 &lt;code&gt;@Functional&lt;/code&gt; 注释的&lt;mark&gt;函数式接口&lt;/mark&gt;，&lt;mark&gt;自带一个抽象函数的方法&lt;/mark&gt;，或者&lt;mark&gt;SAM(Single Abstract Method 单个抽象方法)类型&lt;/mark&gt;。这些称为lambda表达式的目标类型，可以用作返回类型，或lambda目标代码的参数。例如，若一个方法接收Runnable、Comparable或者 Callable 接口，都有单个抽象方法，可以传入lambda表达式。类似的，如果一个方法接受声明于 java.util.function 包内的接口，例如 Predicate、Function、Consumer 或 Supplier，那么可以向其传lambda表达式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;函数式接口&lt;/strong&gt;:&lt;br&gt;
来自Core Java：&lt;br&gt;
对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口称之为&lt;code&gt;函数式接口&lt;/code&gt;。&lt;br&gt;
函数式接口在java中是指:&lt;strong&gt;有且仅有一个抽象方法的接口&lt;/strong&gt;&lt;br&gt;
函数式接口，即适用于函数式编程场景的接口。而java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;@FunctionalInterface注解&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FunctionalInterface // 标明为函数式接口
public abstract MyFunctionInterface{
    void mrthod(); //抽象方法
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。需要注意的是，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。(该接口是一个标记接口)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Lambda 表达式是一个&lt;mark&gt;匿名函数&lt;/mark&gt;，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简写的依据：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;能够使用Lambda的依据是必须有相应的函数接口&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lambda表达式另一个依据是类型推断机制&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 Java 中，Lambda 表达式的格式是像下面这样&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 无参数，无返回值
() -&amp;gt; log.info(&amp;quot;Lambda&amp;quot;)
 // 有参数，有返回值
(int a, int b) -&amp;gt; { a+b }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其等价于&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;log.info(&amp;quot;Lambda&amp;quot;);
private int plus(int a, int b){
      return a+b;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果用匿名内部类的形式写：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println(&amp;quot;快速新建并启动一个线程&amp;quot;);
    }
}).run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.8之后可以用lambda表达式，进一步简化。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new Thread(()-&amp;gt;{
    System.out.println(&amp;quot;快速新建并启动一个线程&amp;quot;);
}).run();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lambda 表达式简化了匿名内部类的形式，可以达到同样的效果，但是 Lambda 要优雅的多。虽然最终达到的目的是一样的，但其实内部的实现原理却不相同。&lt;/p&gt;
&lt;p&gt;匿名内部类在编译之后会创建一个新的匿名内部类出来，而 Lambda 是调用 JVM &lt;code&gt;invokedynamic&lt;/code&gt;指令实现的，&lt;mark&gt;并不会产生新类&lt;/mark&gt;。&lt;/p&gt;
&lt;h2 id=&#34;this引用的意义&#34;&gt;this引用的意义&lt;/h2&gt;
&lt;p&gt;既然Lambda表达式不是内部类的简写，那么Lambda内部的&lt;code&gt;this&lt;/code&gt;引用也就跟内部类对象没什么关系了。在Lambda表达式中&lt;code&gt;this&lt;/code&gt;的意义跟在表达式外部完全一样。因此下列代码将输出两遍&lt;code&gt;Hello Hoolee&lt;/code&gt;，而不是两个引用地址。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Hello {
	Runnable r1 = () -&amp;gt; { System.out.println(this); };
	Runnable r2 = () -&amp;gt; { System.out.println(toString()); };
	public static void main(String[] args) {
		new Hello().r1.run();
		new Hello().r2.run();
	}
	public String toString() { return &amp;quot;Hello Hoolee&amp;quot;; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;方法引用&#34;&gt;方法引用&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是方法引用？&lt;br&gt;
简单地说，就是一个 Lambda 表达式。在 Java 8 中，我们会使用 Lambda 表达式创建匿名方法，但是有时候，我们的 Lambda 表达式可能仅仅调用一个已存在的方法，而不做任何其它事，对于这种情况，通过一个方法名字来引用这个已存在的方法会更加清晰，Java 8 的方法引用允许我们这样做。方法引用是一个更加紧凑，易读的 Lambda 表达式，注意方法引用是一个 Lambda 表达式，其中方法引用的操作符是双冒号 &amp;quot;::&amp;quot;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;方法引用的出现，使得我们可以将一个方法赋给一个变量或者作为参数传递给另外一个方法。&lt;code&gt;::&lt;/code&gt;双冒号作为方法引用的符号，比如下面这两行语句，引用 &lt;code&gt;Integer&lt;/code&gt;类的 &lt;code&gt;parseInt&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Function&amp;lt;String, Integer&amp;gt; s = Integer::parseInt;
Integer i = s.apply(&amp;quot;10&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;方法引用引用的方法是已经存在的方法。&lt;/li&gt;
&lt;li&gt;所有的方法基本都可以被引用。&lt;br&gt;
&lt;strong&gt;Q：返回值到底是什么类型？&lt;/strong&gt;&lt;br&gt;
A：返回的类型是 Java 8 专门定义的函数式接口，这类接口用 &lt;code&gt;@FunctionalInterface&lt;/code&gt; 注解。&lt;br&gt;
有 &lt;code&gt;Function&lt;/code&gt;、&lt;code&gt;Comparator&lt;/code&gt;、 &lt;code&gt;IntBinaryOperator&lt;/code&gt;等等。&lt;br&gt;
比如 &lt;code&gt;Function&lt;/code&gt;这个函数式接口的定义如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FunctionalInterface
public interface Function&amp;lt;T, R&amp;gt; {
    R apply(T t);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以这就引出了下面的一个关键：&lt;br&gt;
你的引用方法的参数个数、类型，返回值类型要和函数式接口中的方法声明一一对应才行。&lt;/p&gt;
&lt;p&gt;比如 &lt;code&gt;Integer.parseInt&lt;/code&gt;方法定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static int parseInt(String s) throws NumberFormatException {
	return parseInt(s,10);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先&lt;code&gt;parseInt&lt;/code&gt;方法的参数个数是 1 个，而 &lt;code&gt;Function&lt;/code&gt;中的 &lt;code&gt;apply&lt;/code&gt;方法参数个数也是 1 个，参数个数对应上了，再来，&lt;code&gt;apply&lt;/code&gt;方法的参数类型和返回类型是泛型类型，所以肯定能和 &lt;code&gt;parseInt&lt;/code&gt;方法对应上。&lt;br&gt;
这样一来，就可以正确的接收&lt;code&gt;Integer::parseInt&lt;/code&gt;的方法引用，并可以调用&lt;code&gt;Funciton&lt;/code&gt;的&lt;code&gt;apply&lt;/code&gt;方法，这时候，调用到的其实就是对应的 &lt;code&gt;Integer.parseInt&lt;/code&gt;方法了。&lt;/p&gt;
&lt;h4 id=&#34;什么场景适合使用方法引用&#34;&gt;什么场景适合使用方法引用:&lt;/h4&gt;
&lt;p&gt;当一个 Lambda 表达式调用了一个已存在的方法&lt;/p&gt;
&lt;h4 id=&#34;什么场景不适合使用方法引用&#34;&gt;什么场景不适合使用方法引用:&lt;/h4&gt;
&lt;p&gt;需要往引用的方法传参数的时候不适合：&lt;/p&gt;
&lt;h1 id=&#34;collection中的新方法&#34;&gt;Collection中的新方法&lt;/h1&gt;
&lt;h2 id=&#34;foreach&#34;&gt;forEach()&lt;/h2&gt;
&lt;p&gt;该方法的签名为&lt;code&gt;void forEach(Consumer&amp;lt;? super E&amp;gt; action)&lt;/code&gt;，作用是对容器中的每个元素执行&lt;code&gt;action&lt;/code&gt;指定的动作，其中&lt;code&gt;Consumer&lt;/code&gt;是个函数接口，里面只有一个待实现方法&lt;code&gt;void accept(T t)&lt;/code&gt;（后面我们会看到，这个方法叫什么根本不重要，你甚至不需要记忆它的名字）。&lt;/p&gt;
&lt;p&gt;需求：&lt;em&gt;假设有一个字符串列表，需要打印出其中所有长度大于3的字符串.&lt;/em&gt;&lt;br&gt;
Java7及以前我们可以用增强的for循环实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 使用增强for循环迭代
ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(&amp;quot;I&amp;quot;, &amp;quot;love&amp;quot;, &amp;quot;you&amp;quot;, &amp;quot;too&amp;quot;));
for(String str : list){
    if(str.length()&amp;gt;3)
        System.out.println(str);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在使用&lt;code&gt;forEach()&lt;/code&gt;方法结合匿名内部类，可以这样实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 使用forEach()结合匿名内部类迭代
ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(&amp;quot;I&amp;quot;, &amp;quot;love&amp;quot;, &amp;quot;you&amp;quot;, &amp;quot;too&amp;quot;));
list.forEach(new Consumer&amp;lt;String&amp;gt;(){
    @Override
    public void accept(String str){
        if(str.length()&amp;gt;3)
            System.out.println(str);
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码调用&lt;code&gt;forEach()&lt;/code&gt;方法，并使用匿名内部类实现&lt;code&gt;Comsumer&lt;/code&gt;接口。到目前为止我们没看到这种设计有什么好处，但是不要忘记Lambda表达式，使用Lambda表达式实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 使用forEach()结合Lambda表达式迭代
ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(&amp;quot;I&amp;quot;, &amp;quot;love&amp;quot;, &amp;quot;you&amp;quot;, &amp;quot;too&amp;quot;));
list.forEach( str -&amp;gt; {
        if(str.length()&amp;gt;3)
            System.out.println(str);
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码给&lt;code&gt;forEach()&lt;/code&gt;方法传入一个Lambda表达式，我们不需要知道&lt;code&gt;accept()&lt;/code&gt;方法，也不需要知道&lt;code&gt;Consumer&lt;/code&gt;接口，类型推导帮我们做了一切。&lt;/p&gt;
&lt;h1 id=&#34;stream&#34;&gt;Stream&lt;/h1&gt;
&lt;h2 id=&#34;1-什么是流&#34;&gt;1. 什么是流？&lt;/h2&gt;
&lt;p&gt;Stream不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的Iterator。原始版本的Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的Stream，用户只要给出需要对其包含的元素执行什么操作，比如，“过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream会隐式地在内部进行遍历，做出相应的数据转换。Stream就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。&lt;/p&gt;
&lt;p&gt;而和迭代器又不同的是，Stream可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个item读完后再读下一个item。&lt;strong&gt;而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。&lt;/strong&gt; Stream的并行操作依赖于Java7中引入的Fork/Join框架（JSR166y）来拆分任务和加速处理过程。&lt;/p&gt;
&lt;p&gt;Stream 的另外一大特点是，数据源本身可以是无限的。&lt;/p&gt;
&lt;h2 id=&#34;2-流的构成&#34;&gt;2. 流的构成&lt;/h2&gt;
&lt;p&gt;当我们使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换 → 执行操作获取想要的结果。&lt;strong&gt;每次转换原有Stream对象不改变，返回一个新的Stream对象（可以有多次转换）&lt;/strong&gt;，这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示:&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685699610010.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-stream生成方式&#34;&gt;3. Stream生成方式&lt;/h2&gt;
&lt;p&gt;（1）从Collection和数组获得&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Collection.stream()&lt;/li&gt;
&lt;li&gt;Collection.parallelStream()&lt;/li&gt;
&lt;li&gt;Arrays.stream(T array) or Stream.of()&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;（2）从BufferedReader获得&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;java.io.BufferedReader.lines()&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;（3）静态工厂&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;java.util.stream.IntStream.range()&lt;/li&gt;
&lt;li&gt;java.nio.file.Files.walk()&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;（4）自己构建&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;java.util.Spliterator&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;（5）其他&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Random.ints()&lt;/li&gt;
&lt;li&gt;BitSet.stream()&lt;/li&gt;
&lt;li&gt;Pattern.splitAsStream(java.lang.CharSequence)&lt;/li&gt;
&lt;li&gt;JarFile.stream()&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-流的操作类型&#34;&gt;4. 流的操作类型&lt;/h2&gt;
&lt;p&gt;流的操作类型分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;mark&gt;Intermediate&lt;/mark&gt;：一个流可以后面跟随零个或多个intermediate操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;mark&gt;Terminal&lt;/mark&gt;：一个流只能有一个terminal操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以,这必定是流的最后一个操作。Terminal操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个side effect。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在对一个Stream进行多次转换操作(Intermediate 操作)，每次都对Stream的每个元素进行转换，而且是执行多次，这样时间复杂度就是N（转换次数）个for循环里把所有操作都做掉的总和吗？其实不是这样的，&lt;strong&gt;转换操作都是lazy的，多个转换操作只会在Terminal操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在Terminal 操作的时候循环Stream对应的集合，然后对每个元素执行所有的函数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还有一种操作被称为&lt;strong&gt;short-circuiting&lt;/strong&gt;。用以指：对于一个intermediate操作，如果它接受的是一个无限大（infinite/unbounded）的Stream，但返回一个有限的新Stream；对于一个terminal操作，如果它接受的是一个无限大的Stream，但能在有限的时间计算出结果。&lt;br&gt;
当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个short-circuiting操作是必要非充分条件。&lt;/p&gt;
&lt;h2 id=&#34;5-流的使用&#34;&gt;5. 流的使用&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;简单说，&lt;strong&gt;对Stream的使用就是实现一个filter-map-reduce过程，产生一个最终结果，或者导致一个副作用（side effect）。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1-流的构造与转换&#34;&gt;1. 流的构造与转换&lt;/h3&gt;
&lt;p&gt;下面提供最常见的几种构造Stream的例子:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 1. Individual values
Stream stream = Stream.of(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;);
// 2. Arrays
String [] strArray = new String[] {&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;};
stream = Stream.of(strArray);
stream = Arrays.stream(strArray);
// 3. Collections
List&amp;lt;String&amp;gt; list = Arrays.asList(strArray);
stream = list.stream();
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;需要注意的是，对于基本数值型，目前有三种对应的包装类型Stream：IntStream、LongStream、DoubleStream。当然我们也可以用&lt;code&gt; Stream&amp;lt;Integer&amp;gt;&lt;/code&gt;、&lt;code&gt;Stream&amp;lt;Long&amp;gt;&lt;/code&gt;和&lt;code&gt;Stream&amp;lt;Double&amp;gt;&lt;/code&gt;，但是boxing/unboxing会很耗时，所以特别为这三种基本数值型提供了对应的Stream。&lt;/p&gt;
&lt;p&gt;Java8中还没有提供其它数值型Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种Stream进行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;IntStream.of(new int[]{1, 2, 3}).forEach(System.out::println);
IntStream.range(1, 3).forEach(System.out::println);
IntStream.rangeClosed(1, 3).forEach(System.out::println);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;流也可以转换为其它数据结构，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 1. Array
String[] strArray1 = stream.toArray(String[]::new);
// 2. Collection
List&amp;lt;String&amp;gt; list1 = stream.collect(Collectors.toList());
List&amp;lt;String&amp;gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new));
Set set1 = stream.collect(Collectors.toSet());
Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));
// 3. String
String str = stream.collect(Collectors.joining()).toString();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-流的操作&#34;&gt;2. 流的操作&lt;/h3&gt;
&lt;p&gt;接下来，当把一个数据结构包装成Stream后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Intermediate 操作&lt;/p&gt;
&lt;p&gt;map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Terminal 操作&lt;/p&gt;
&lt;p&gt;forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Short-circuiting 操作&lt;/p&gt;
&lt;p&gt;anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit&lt;/p&gt;
&lt;p&gt;我们下面看一下Stream的比较典型用法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;1-intermediate-操作&#34;&gt;1. Intermediate 操作&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;map/flatMap&lt;br&gt;
　我们先来看map，它的作用就是把inputStream的每个元素映射成outputStream的另外一个元素，例如：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;Integer&amp;gt; nums = Arrays.asList(1, 2, 3, 4);
List&amp;lt;Integer&amp;gt; squareNums = nums.stream().map(n -&amp;gt; n * n)
.collect(Collectors.toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上面例子可以看出，map生成的是个1:1映射，每个输入元素都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要flatMap，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; inputStream = Stream.of(
 Arrays.asList(1),
 Arrays.asList(2, 3),
 Arrays.asList(4, 5, 6)
 );
Stream&amp;lt;Integer&amp;gt; outputStream = inputStream.
flatMap((childList) -&amp;gt; childList.stream());
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;flatmap把inputstream中的层级结构-扁平化就是将最底层元素抽出来放到一起最终output的新stream里面已经没有list了都是直接的数字&#34;&gt;flatMap把inputStream中的层级结构 扁平化，就是将最底层元素抽出来放到一起，最终output的新Stream里面已经没有List了，都是直接的数字。&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;filter&lt;br&gt;
　filter对原始Stream进行某项测试，通过测试的元素被留下来生成一个新Stream。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 留下偶数
Integer[] sixNums = {1, 2, 3, 4, 5, 6};
Integer[] evens =
Stream.of(sixNums).filter(n -&amp;gt; n%2 == 0).toArray(Integer[]::new);
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;forEach&lt;br&gt;
　forEach方法接收一个Lambda表达式，然后在Stream的每一个元素上执行该表达式。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 对一个人员集合遍历，找出男性并打印姓名。
roster.stream().filter(p -&amp;gt; p.getGender() == Person.Sex.MALE)
.forEach(p -&amp;gt; System.out.println(p.getName()));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出来，forEach是为Lambda而设计的，保持了最紧凑的风格。当需要为多核系统优化时，可以parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时forEach本身的实现不需要调整，而Java8以前的for循环代码可能需要加入额外的多线程逻辑。但一般认为，forEach和常规for循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。&lt;/p&gt;
&lt;p&gt;另外一点需要注意，forEach是terminal操作。因此，它执行后，Stream 的元素就被“消费”掉了，你无法对一个Stream进行两次terminal运算。下面的代码是错误的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;     stream.forEach(element -&amp;gt; doOneThing(element));
     stream.forEach(element -&amp;gt; doAnotherThing(element));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相反，具有相似功能的intermediate操作peek可以达到上述目的。如下是出现在Stream api javadoc上的一个示例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// peek 对每个元素执行操作并返回一个新的 Stream
Stream.of(&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;, &amp;quot;four&amp;quot;).filter(e -&amp;gt; e.length() &amp;gt; 3)
 .peek(e -&amp;gt; System.out.println(&amp;quot;Filtered value: &amp;quot; + e)).map(String::toUpperCase)
 .peek(e -&amp;gt; System.out.println(&amp;quot;Mapped value: &amp;quot; + e)).collect(Collectors.toList());
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;foreach-不能修改自己包含的本地变量值也不能用breakreturn之类的关键字提前结束循环&#34;&gt;&lt;strong&gt;forEach 不能修改自己包含的本地变量值，也不能用break/return之类的关键字提前结束循环。&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;limit/skip&lt;/p&gt;
&lt;p&gt;limit返回Stream的前面n个元素；skip则是扔掉前n个元素（它是由一个叫 subStream的方法改名而来）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//limit 和 skip 对运行次数的影响
public void testLimitAndSkip() {
 List&amp;lt;Person&amp;gt; persons = new ArrayList();
 for (int i = 1; i &amp;lt;= 10000; i++) {
 Person person = new Person(i, &amp;quot;name&amp;quot; + i);
 persons.add(person);
 }
List&amp;lt;String&amp;gt; personList2 = persons.stream().
map(Person::getName).limit(10).skip(3).collect(Collectors.toList());
 System.out.println(personList2);
}
private class Person {
 public int no;
 private String name;
 public Person (int no, String name) {
 this.no = no;
 this.name = name;
 }
 public String getName() {
 System.out.println(name);
 return name;
 }
}

输出结果为：
name1
name2
name3
name4
name5
name6
name7
name8
name9
name10
[name4, name5, name6, name7, name8, name9, name10]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是一个有10，000个元素的Stream，但在short-circuiting操作limit和skip的作用下，管道中map操作指定的getName()方法的执行次数为 limit 所限定的10次，而最终返回结果在跳过前3个元素后只有后面7个返回。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;sorted&lt;/p&gt;
&lt;p&gt;对Stream的排序通过sorted进行，它比数组的排序更强之处在于你可以首先对Stream进行各类map、filter、limit、skip甚至distinct来减少元素数量后再排序，这能帮助程序明显缩短执行时间。例如：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 优化：排序前进行 limit 和 skip
List&amp;lt;Person&amp;gt; persons = new ArrayList();
 for (int i = 1; i &amp;lt;= 5; i++) {
 Person person = new Person(i, &amp;quot;name&amp;quot; + i);
 persons.add(person);
 }

List&amp;lt;Person&amp;gt; personList2 = persons.stream().limit(2).sorted((p1, p2) -&amp;gt; p1.getName().compareTo(p2.getName())).collect(Collectors.toList());
System.out.println(personList2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果会简单很多：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;name2
name1
[stream.StreamDW$Person@6ce253f1,stream.StreamDW$Person@53d8d10a]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，这种优化是有business logic上的局限性的：即不要求排序后再取值。&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Stream&lt;/code&gt; 的 &lt;code&gt;collect&lt;/code&gt; 操作是将流中的元素收集到一个可变容器或聚合操作中的结果。它是一个终端操作，用于将流中的元素进行聚合、转换或分组，并将结果收集到一个集合中，如列表、集合、映射等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;collect&lt;/code&gt; 操作的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;R&amp;gt; R collect(Collector&amp;lt;? super T, A, R&amp;gt; collector)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;Collector&lt;/code&gt; 是一个用于描述收集操作的接口，它定义了将元素收集到容器中所需的操作。&lt;code&gt;collect&lt;/code&gt; 方法接受一个 &lt;code&gt;Collector&lt;/code&gt; 参数，根据 &lt;code&gt;Collector&lt;/code&gt; 的定义，将流中的元素进行收集，并返回最终的结果。&lt;br&gt;
&lt;code&gt;Collector&lt;/code&gt; 接口中定义了一些用于收集操作的静态方法，例如 &lt;code&gt;toList()&lt;/code&gt;、&lt;code&gt;toSet()&lt;/code&gt;、&lt;code&gt;toMap()&lt;/code&gt; 等，它们提供了常见的收集操作。&lt;/p&gt;
&lt;h2 id=&#34;小结&#34;&gt;小结&lt;/h2&gt;
&lt;p&gt;总之，Stream 的特性可以归纳为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不是数据结构;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它没有内部存储，它只是用操作管道从source（数据结构、数组、generator function、IO channel）抓取数据;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它也绝不修改自己所封装的底层数据结构的数据。例如Stream的filter操作会产生一个不包含被过滤元素的新Stream，而不是从source删除那些元素;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有Stream的操作必须以lambda表达式为参数;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不支持索引访问;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你可以请求第一个元素，但无法请求第二个，第三个，或最后一个;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;很容易生成数组或者List;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;惰性化;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;很多Stream操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Intermediate操作永远是惰性化的;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并行能力;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以是无限的。集合有固定大小，Stream 则不必。limit(n)和findFirst()这类的short-circuiting操作可以对无限的Stream进行运算并很快完成。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考文档：&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/justloveyou_/article/details/79562574&#34;&gt;https://blog.csdn.net/justloveyou_/article/details/79562574&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.jianshu.com/p/4a3da6a11b58&#34;&gt;https://www.jianshu.com/p/4a3da6a11b58&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/jimoer/p/10995574.html&#34;&gt;https://www.cnblogs.com/jimoer/p/10995574.html&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://objcoding.com/2019/03/04/lambda/&#34;&gt;https://objcoding.com/2019/03/04/lambda/&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://pdai.tech/md/java/java8/java8-stream.html&#34;&gt;https://pdai.tech/md/java/java8/java8-stream.html&lt;/a&gt;&lt;/p&gt;
">Lambda表达式，方法引用与Stream Api</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/egLXlw_ge/"" data-c="
          &lt;h1 id=&#34;1设计模式原则&#34;&gt;1.设计模式原则&lt;/h1&gt;
&lt;h2 id=&#34;单一职责原则&#34;&gt;单一职责原则：&lt;/h2&gt;
&lt;p&gt;学生工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;辅导员：生活辅导&lt;/li&gt;
&lt;li&gt;学业导师：学业辅导&lt;br&gt;
单一职责原则 &lt;strong&gt;:一个类只负责一项职责&lt;/strong&gt;&lt;br&gt;
不能存在多于一个导致类变更的原因&lt;br&gt;
单一职责原则符合&amp;quot;高内聚,低耦合&amp;quot;的思想&lt;br&gt;
单一职责原则不只是面向对象编程思想所特有的,只要是模块化的程序设计,都适用单一职责原则&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;开闭原则open-close-principle&#34;&gt;开闭原则(Open Close Principle)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;开闭原则 &lt;strong&gt;:对扩展开放,对修改关闭&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;程序进行扩展的时候,不能修改原有的代码,&lt;/strong&gt; 实现一个热插拔的效果&lt;/li&gt;
&lt;li&gt;为了使程序扩展性好,易于维护和升级:需要&lt;strong&gt;使用接口和抽象类&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;里氏代换原则liskov-substitution-principle&#34;&gt;里氏代换原则(Liskov Substitution Principle)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;里氏代换原则 &lt;strong&gt;:任何基类可以出现的地方,子类一定可以出现&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;LSP是&lt;strong&gt;继承复用&lt;/strong&gt;的基石,只有&lt;strong&gt;当衍生类可以替换掉基类,软件单位的功能不受影响时,&lt;/strong&gt; 基类才能真正被复用,衍生类也能够在基类的基础上增加新的行为&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;里氏代换原则是对实现抽象化的具体步骤的规范:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;里氏代换原则是对开闭原则的补充&lt;/li&gt;
&lt;li&gt;实现开闭原则的关键步骤就是抽象化&lt;/li&gt;
&lt;li&gt;基类与子类的继承关系就是抽象化的具体实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;依赖倒转原则dependence-inversion-principle&#34;&gt;依赖倒转原则(Dependence Inversion Principle)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;依赖倒转原则 &lt;strong&gt;:针对接口编程,依赖于抽象而不依赖于具体&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;依赖倒转原则是开闭原则的基础&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;接口隔离原则interface-segregation-principle&#34;&gt;接口隔离原则(Interface Segregation Principle)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;接口隔离原则 &lt;strong&gt;:使用多个隔离的接口,比使用单个接口要好,降低类之间的耦合度&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;从接口隔离原则可以看出:设计模式就是一个软件的设计思想&lt;/li&gt;
&lt;li&gt;从大型软件架构出发,为了升级和维护方便 &lt;strong&gt;:降低依赖,降低耦合&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;迪米特法则最少知道原则demeter-principle&#34;&gt;迪米特法则(最少知道原则)(Demeter Principle)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;迪米特法则:最少知道原则 &lt;strong&gt;,一个实体应当尽量少的与其它实体发生相互作用,使得功能模块相互独立&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;合成复用原则composite-reuse-principle&#34;&gt;合成复用原则(Composite Reuse Principle)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;合成复用原则 &lt;strong&gt;:尽量使用合成或者聚合的方式,而不是使用继承&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;避免类之间的紧耦合关系&lt;/li&gt;
&lt;li&gt;可以动态地替换组件&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2-简单工厂模式&#34;&gt;2. 简单工厂模式&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;工厂模式主要是用于对实现逻辑的封装，并且通过对公共的接口提供对象的实列化的服务，在我添加新的类时不需大动干戈，只要修改一点点就好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单工厂的实例：&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685699326278.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
简单工厂几种实现方式：&lt;/p&gt;
&lt;h2 id=&#34;21-静态工厂模式&#34;&gt;2.1 静态工厂模式&lt;/h2&gt;
&lt;p&gt;手机类的接口，定义手机的规范：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Phone {  
     void display();  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两种手机：Iphone和Huawei&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IPhone implements Phone {  
    IPhone(){  
        this.display();  
    }  
    @Override  
    public void display() {  
        System.out.println(&amp;quot;60hz+ios&amp;gt;120hz&amp;quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Huawei implements Phone{  
    Huawei(){  
        this.display();  
    }  
    @Override  
    public void display() {  
        System.out.println(&amp;quot;4g+harmony&amp;gt;5g&amp;quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生产手机的工厂类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class PhoneFactory {  
    public Phone makePhone(String phoneType){  
        if(phoneType.equals(&amp;quot;Iphone&amp;quot;)){  
            return new IPhone();  
        } else if (phoneType.equals(&amp;quot;Huawei&amp;quot;)) {  
            return new Huawei();  
        }  
        return null;  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class demo {  
    public static void main(String[] args) {  
        PhoneFactory phoneFactory = new PhoneFactory();  
        Phone iphone = phoneFactory.makePhone(&amp;quot;Iphone&amp;quot;);  
    }  
}
//输出；60hz+ios&amp;gt;120hz
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要点：当你需要什么，只需要传入一个&lt;mark&gt;正确的参数&lt;/mark&gt;，就可以获取你所需要的对象，而无须知道其创建细节。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;问题：工厂指责过重，增加新的产品需要修改工厂类的判断逻辑，需要修改代码，这一点与开闭原则是相违背的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由此问题，想到应该去改进。&lt;br&gt;
一种思路：利用反射&lt;/p&gt;
&lt;h2 id=&#34;22-利用反射来实现简单工厂模式&#34;&gt;2.2 利用反射来实现简单工厂模式&lt;/h2&gt;
&lt;p&gt;产品类的代码不变&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class PhoneFactory {  //反射工厂
    private static final Map&amp;lt;String,Class&amp;gt; phoneMap = new HashMap&amp;lt;&amp;gt;();  
    public static void addPhoneMap(String phoneType,Class newPhone){  
        phoneMap.put(phoneType,newPhone);  
    }  
  
    public Phone makePhone(String phoneType) throws Exception {  
        Class phoneClass = phoneMap.get(phoneType);  
        return (Phone) phoneClass.newInstance();  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class demo {  
    public static void main(String[] args) throws Exception {  
        addPhoneMap(&amp;quot;IPhone&amp;quot;, IPhone.class);  
        PhoneFactory phoneFactory = new PhoneFactory();  
        Phone iphone = phoneFactory.makePhone(&amp;quot;IPhone&amp;quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但这种方式也有缺点：反射会降低程序的运行效率，对性能要求较高的场景应该避免这种写法。&lt;/p&gt;
&lt;p&gt;所以就有了下面的设计模式：工厂模式。&lt;/p&gt;
&lt;h1 id=&#34;3-工厂模式&#34;&gt;3. 工厂模式&lt;/h1&gt;
&lt;p&gt;和简单工厂模式中工厂负责生产所有产品相比，工厂方法模式将生成具体产品的任务分发给具体的产品工厂，我们的工厂类直接被抽象化，需要具体特定化的逻辑代码转移到实现抽象方法的子类中，这样我们就不要再去修改工厂类（即：不用再去做什么if else 修改）这也是我们当前比较常用的一种方式。（即再创造一个工厂用于创造工厂类对象）如图所示：&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685699370749.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;以图片加载器为例：&lt;br&gt;
Product：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Reader {  
    void read();  
}

public class PngReader implements Reader {  //加载jpg
    @Override  
    public void read() {  
        System.out.print(&amp;quot;read png&amp;quot;);  
    }  
}

public class JpgReader implements Reader {  //加载png
    @Override  
    public void read() {  
        System.out.print(&amp;quot;read jpg&amp;quot;);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Factory：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface ReaderFactory {  
    Reader getReader();  
}

public class JpgReaderFactory implements ReaderFactory{  //生产jpgreader的工厂
    @Override  
    public Reader getReader() {  
        return new JpgReader();  
    }  
}

public class PngReaderFactory implements ReaderFactory{  //生产pngreader的工厂
    @Override  
    public Reader getReader() {  
        return new PngReader();  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Demo：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class demo {  
    public static void main(String[] args) {  
        ReaderFactory readerFactory = new JpgReaderFactory();  
        Reader reader = readerFactory.getReader();  
        reader.read();  
    }  
}
//output:read jpg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和简单工厂对比一下，最根本的区别在于，简单工厂只有一个统一的工厂类，而工厂方法是针对每个要创建的对象都会提供一个工厂类，这些工厂类都实现了一个工厂基类（本例中的ReaderFactory ）。&lt;br&gt;
使用场景：&lt;br&gt;
（1）客户端不需要知道它所创建的对象的类。例子中我们不知道每个图片加载器具体叫什么名，只知道创建它的工厂名就完成了床架过程。&lt;br&gt;
（2）客户端可以通过子类来指定创建对应的对象。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;问题：什么时候用简单工厂模式，什么时候用工厂模式呢？&lt;/p&gt;
&lt;p&gt;引用设计模式之美里面的一句话：当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。&lt;br&gt;
而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;工厂模式下还可以进一步延伸为抽象工厂模式：&lt;/p&gt;
&lt;h1 id=&#34;4-抽象工厂模式&#34;&gt;4.  抽象工厂模式&lt;/h1&gt;
&lt;p&gt;问题：假设你正在开发一款家具商店模拟器。 你的代码中包括一些类， 用于表示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一系列相关产品， 例如 &lt;code&gt;椅子&lt;/code&gt;Chair 、 ​ &lt;code&gt;沙发&lt;/code&gt;Sofa和 &lt;code&gt;咖啡桌&lt;/code&gt;Coffee­Table 。&lt;/li&gt;
&lt;li&gt;系列产品的不同变体。 例如， 你可以使用 &lt;code&gt;现代&lt;/code&gt;Modern 、 ​ &lt;code&gt;维多利亚&lt;/code&gt;Victorian 、 ​ &lt;code&gt;装饰风艺术&lt;/code&gt;Art­Deco等风格生成 &lt;code&gt;椅子&lt;/code&gt; 、 ​ &lt;code&gt;沙发&lt;/code&gt;和 &lt;code&gt;咖啡桌&lt;/code&gt; 。&lt;br&gt;
如图：&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685699387824.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
用上面的工厂模式去实现的话，就需要一个椅子抽象工厂，沙发抽象工厂和咖啡桌抽象工厂，显然不够优雅，我们的目的是利用一个抽象工厂就可以生产所有类型的家具。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;工厂方法类中只有一个抽象方法，要想实现多种不同的类对象，只能去创建不同的具体工厂方法的子类来实列化，而抽象工厂 则是让一个工厂负责创建多个不同类型的对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该例应用抽象工厂模式的示意图：&lt;img src=&#34;https://silentiris.github.io/post-images/1685699400645.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
项目组织：&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685699408541.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;代码示例的话太长了，这里先不放了。&lt;/p&gt;
&lt;p&gt;抽象工厂模式的结构&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685699418621.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;应用场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。&lt;/li&gt;
&lt;li&gt;如果你有一个基于一组抽象方法的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式。&lt;/li&gt;
&lt;/ol&gt;
">工厂模式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/jZ3IrV_aj/"" data-c="
          &lt;h1 id=&#34;关于作者&#34;&gt;关于作者&lt;/h1&gt;
&lt;p&gt;一名cs专业的普通大学生，记录自己学习过程的感悟与收获。&lt;br&gt;
主要方向为后端和运维。常用语言java和go。&lt;/p&gt;
&lt;h1 id=&#34;如何联系&#34;&gt;如何联系&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;mailto:s1lentdragon@outlook.com&#34;&gt;s1lentdragon@outlook.com&lt;/a&gt;&lt;/p&gt;
">about</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://silentiris.github.io/post/Pdx6GoeCX/"" data-c="
          &lt;h1 id=&#34;注解的基础知识&#34;&gt;注解的基础知识&lt;/h1&gt;
&lt;p&gt;注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它主要的作用有以下四方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成文档，通过代码里标识的元数据生成javadoc文档。&lt;/li&gt;
&lt;li&gt;编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。&lt;/li&gt;
&lt;li&gt;编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。&lt;/li&gt;
&lt;li&gt;运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这么来说是比较抽象的，我们具体看下注解的常见分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Java自带的标准注解&lt;/strong&gt;，包括&lt;code&gt;@Override&lt;/code&gt;、&lt;code&gt;@Deprecated&lt;/code&gt;和&lt;code&gt;@SuppressWarnings&lt;/code&gt;，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;元注解&lt;/strong&gt;，元注解是用于定义注解的注解，包括&lt;code&gt;@Retention&lt;/code&gt;、&lt;code&gt;@Target&lt;/code&gt;、&lt;code&gt;@Inherited&lt;/code&gt;、&lt;code&gt;@Documented&lt;/code&gt;，&lt;code&gt;@Retention&lt;/code&gt;用于标明注解被保留的阶段，&lt;code&gt;@Target&lt;/code&gt;用于标明注解使用的范围，&lt;code&gt;@Inherited&lt;/code&gt;用于标明注解可继承，&lt;code&gt;@Documented&lt;/code&gt;用于标明是否生成javadoc文档。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自定义注解&lt;/strong&gt;，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;java内置注解&#34;&gt;java内置注解&lt;/h2&gt;
&lt;p&gt;Java 1.5开始自带的标准注解，包括&lt;code&gt;@Override&lt;/code&gt;、&lt;code&gt;@Deprecated&lt;/code&gt;和&lt;code&gt;@SuppressWarnings&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Override&lt;/code&gt;：表示当前的方法定义将覆盖父类中的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Deprecated&lt;/code&gt;：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Documented @Retention(RetentionPolicy.RUNTIME)
@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE}) public @interface Deprecated { 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@SuppressWarnings&lt;/code&gt;：表示关闭编译器警告信息&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE}) @Retention(RetentionPolicy.SOURCE) 
public @interface SuppressWarnings { 
	String[] value();
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;元注解&#34;&gt;元注解&lt;/h2&gt;
&lt;p&gt;上述内置注解的定义中使用了一些元注解（注解类型进行注解的注解类），在JDK 1.5中提供了4个标准的元注解：&lt;code&gt;@Target&lt;/code&gt;，&lt;code&gt;@Retention&lt;/code&gt;，&lt;code&gt;@Documented&lt;/code&gt;，&lt;code&gt;@Inherited&lt;/code&gt;, 在JDK 1.8中提供了两个元注解 &lt;code&gt;@Repeatable&lt;/code&gt;和&lt;code&gt;@Native&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;元注解-target&#34;&gt;元注解 - @Target&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Target注解的作用是：描述注解的使用范围（即：被修饰的注解可以用在什么地方） 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Target注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数），在定义注解类时使用了@Target 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在ElementType 枚举中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum ElementType {
 
    TYPE, // 类、接口、枚举类
 
    FIELD, // 成员变量（包括：枚举常量）
 
    METHOD, // 成员方法
 
    PARAMETER, // 方法参数
 
    CONSTRUCTOR, // 构造方法
 
    LOCAL_VARIABLE, // 局部变量
 
    ANNOTATION_TYPE, // 注解类

    PACKAGE, // 可用于修饰：包
 
    TYPE_PARAMETER, // 类型参数，JDK 1.8 新增
 
    TYPE_USE // 使用类型的任何地方，JDK 1.8 新增
 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;元注解-retention-retentiontarget&#34;&gt;元注解 - @Retention &amp;amp; @RetentionTarget&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Reteniton注解的作用是：描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时） 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Reteniton注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在RetentionPolicy枚举中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum RetentionPolicy {
 
    SOURCE,    // 源文件保留
    CLASS,       // 编译期保留，默认值
    RUNTIME   // 运行期保留，可通过反射去获取注解信息
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;元注解-documented&#34;&gt;元注解 - @Documented&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Documented注解的作用是：描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下代码在使用Javadoc工具可以生成&lt;code&gt;@TestDocAnnotation&lt;/code&gt;注解信息。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;
 
@Documented
@Target({ElementType.TYPE,ElementType.METHOD})
public @interface TestDocAnnotation {
 
	public String value() default &amp;quot;default&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;元注解-inherited&#34;&gt;元注解 - @Inherited&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Inherited注解的作用：被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;注解与反射接口&#34;&gt;注解与反射接口&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;定义注解后，如何获取注解中的内容呢？反射包java.lang.reflect下的AnnotatedElement接口提供这些方法。这里注意：只有注解被定义为RUNTIME后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息。我们看下具体的先关接口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boolean isAnnotationPresent(Class&amp;lt;?extends Annotation&amp;gt; annotationClass)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。注意：此方法会忽略注解对应的注解容器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;T extends Annotation&amp;gt; T getAnnotation(Class&amp;lt;T&amp;gt; annotationClass)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Annotation[] getAnnotations()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;T extends Annotation&amp;gt; T[] getAnnotationsByType(Class&amp;lt;T&amp;gt; annotationClass)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回该程序元素上存在的、指定类型的注解数组。没有注解对应类型的注解时，返回长度为0的数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。&lt;code&gt;getAnnotationsByType&lt;/code&gt;方法与 &lt;code&gt;getAnnotation&lt;/code&gt;的区别在于，&lt;code&gt;getAnnotationsByType&lt;/code&gt;会检测注解对应的重复注解容器。若程序元素为类，当前类上找不到注解，且该注解为可继承的，则会去父类上检测对应的注解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;T extends Annotation&amp;gt; T getDeclaredAnnotation(Class&amp;lt;T&amp;gt; annotationClass)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释。如果没有注释直接存在于此元素上，则返回null&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;T extends Annotation&amp;gt; T[] getDeclaredAnnotationsByType(Class&amp;lt;T&amp;gt; annotationClass)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Annotation[] getDeclaredAnnotations()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回直接存在于此元素上的所有注解及注解对应的重复注解容器。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注释直接存在于此元素上，则返回长度为零的一个数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。&lt;/p&gt;
&lt;h2 id=&#34;自定义注解&#34;&gt;自定义注解&lt;/h2&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Target(ElementType.METHOD) 
@Retention(RetentionPolicy.RUNTIME) 
public @interface MyMethodAnnotation { 
	public String title() default &amp;quot;&amp;quot;; 
	public String description() default &amp;quot;&amp;quot;; 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;前置知识动态代理&#34;&gt;前置知识：动态代理&lt;/h1&gt;
&lt;p&gt;在动态代理中，通过 &lt;code&gt;Proxy&lt;/code&gt; 类的 &lt;code&gt;newProxyInstance()&lt;/code&gt; 方法创建代理对象时，会在运行时动态生成一个新的代理类。&lt;br&gt;
具体的代理类生成过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 &lt;code&gt;Proxy.getProxyClass()&lt;/code&gt; 方法获取代理类的 &lt;code&gt;Class&lt;/code&gt; 对象。该方法接收类加载器（&lt;code&gt;ClassLoader&lt;/code&gt;）和要实现的接口数组作为参数，并返回代理类的 &lt;code&gt;Class&lt;/code&gt; 对象。&lt;/li&gt;
&lt;li&gt;根据获取的代理类的 &lt;code&gt;Class&lt;/code&gt; 对象，使用 &lt;code&gt;Class.newInstance()&lt;/code&gt; 或者 &lt;code&gt;Constructor.newInstance()&lt;/code&gt; 方法创建代理类的实例。这个实例就是最终生成的代理对象。&lt;/li&gt;
&lt;li&gt;生成的代理对象会继承自 &lt;code&gt;Proxy&lt;/code&gt; 类并实现目标接口，从而具备目标接口的行为。&lt;br&gt;
需要注意的是，代理类的生成过程是在运行时动态完成的。具体的实现方式可能会有所不同，可以采用字节码生成技术（如动态生成字节码），或者通过库和框架提供的工具类来实现。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在动态代理中，当调用代理对象的某个方法时，实际上会委托给 &lt;code&gt;InvocationHandler&lt;/code&gt; 的 &lt;code&gt;invoke()&lt;/code&gt; 方法来处理。在 &lt;code&gt;invoke()&lt;/code&gt; 方法中，我们可以对方法调用进行自定义处理逻辑。&lt;br&gt;
在代理对象的生成过程中，会创建一个新的代理类，该代理类继承自 &lt;code&gt;Proxy&lt;/code&gt; 类，并实现了目标接口。这个代理类中会重写目标接口中的方法，以实现自定义的行为。&lt;br&gt;
具体来说，当你通过动态代理调用 &lt;code&gt;cat.eat()&lt;/code&gt; 方法时，会触发代理类中对应的 &lt;code&gt;eat()&lt;/code&gt; 方法。这个方法会在内部调用 &lt;code&gt;InvocationHandler&lt;/code&gt; 的 &lt;code&gt;invoke()&lt;/code&gt; 方法，并传递相应的参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface Animal {  
    void eat();  
}

public class Cat implements Animal {  
    @Override  
    public void eat() {  
        System.out.println(&amp;quot;鱼鱼，香香&amp;quot;);  
    }  
}

public class AnimalHandler implements InvocationHandler {  
    private Object bean;  
    public AnimalHandler(Object object){  
        this.bean = object;  
    }  
    @Override  
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {  
        System.out.println(&amp;quot;Before invoke &amp;quot;  + method.getName());  
        method.invoke(bean, args);  
        System.out.println(&amp;quot;After invoke &amp;quot; + method.getName());  
        return null;    
        }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Demo:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class DynamicProxyDemo {  
    public static void main(String[] args) {  
        AnimalHandler animalHandler = new AnimalHandler(new Cat());  
        Animal cat = (Animal) Proxy.newProxyInstance(Animal.class.getClassLoader(),new Class[]{Animal.class},animalHandler);  
        cat.eat();  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;Proxy.newProxyInstance()&lt;/code&gt; 方法中，有三个参数，分别是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;类加载器（ClassLoader）：指定用于加载代理类的类加载器。代理类是在运行时动态生成的，所以需要指定一个类加载器来加载这个代理类。一般情况下，可以使用目标类的类加载器作为参数，例如 &lt;code&gt;target.getClass().getClassLoader()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;接口数组：指定代理类要实现的接口。代理对象会实现这些接口，并提供接口中定义的方法。可以传递多个接口，通过数组的形式指定，例如 &lt;code&gt;new Class&amp;lt;?&amp;gt;[] { SomeInterface.class, AnotherInterface.class }&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;调用处理器（InvocationHandler）：指定代理对象的调用处理器。调用处理器是一个实现了 &lt;code&gt;InvocationHandler&lt;/code&gt; 接口的对象，它负责处理代理对象的方法调用。在代理对象的方法被调用时，会委托给调用处理器的 &lt;code&gt;invoke()&lt;/code&gt; 方法进行处理。通过自定义的调用处理器，可以实现自定义的逻辑，例如执行一些前置或后置操作。一般情况下，可以创建一个实现了 &lt;code&gt;InvocationHandler&lt;/code&gt; 接口的类的实例，并将其作为参数传递给 &lt;code&gt;Proxy.newProxyInstance()&lt;/code&gt; 方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;invoke(Object proxy, Method method, Object[] args)&lt;/code&gt; 是 &lt;code&gt;InvocationHandler&lt;/code&gt; 接口中的方法，用于处理代理对象的方法调用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;proxy&lt;/code&gt; 参数是代理对象本身，也就是通过动态代理生成的对象。在 &lt;code&gt;invoke()&lt;/code&gt; 方法中，我们可以使用 &lt;code&gt;proxy&lt;/code&gt; 对象来调用代理对象的其他方法，或者将其作为参数传递给其他方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;method&lt;/code&gt; 参数是被调用的方法对象，它包含了被调用方法的信息，例如方法名、参数类型等。我们可以通过 &lt;code&gt;method&lt;/code&gt; 对象获取到这些信息，并在 &lt;code&gt;invoke()&lt;/code&gt; 方法中根据需要处理方法调用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;args&lt;/code&gt; 参数是方法调用时传递的参数数组。如果被调用方法有参数，那么这个参数数组中包含了实际传递给方法的参数值。我们可以通过 &lt;code&gt;args&lt;/code&gt; 数组获取到这些参数值，并在 &lt;code&gt;invoke()&lt;/code&gt; 方法中根据需要处理这些参数。&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;注解的底层实现&#34;&gt;注解的底层实现&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Retention(RetentionPolicy.RUNTIME)  
@Target(ElementType.TYPE)  
public @interface MyAnnotation {  //自定义注解
        String value() default &amp;quot;I&#39;m an annotation.&amp;quot;;  
}

//Demo
@MyAnnotation  
public class AnnotationDemo {  
    public static void main(String[] args) {  
        MyAnnotation myAnnotation = AnnotationDemo.class.getDeclaredAnnotation(MyAnnotation.class);  
        System.out.println(myAnnotation.value());  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在idea中查看类继承关系图&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685627663133.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现&lt;code&gt;MyAnnotation&lt;/code&gt;继承自&lt;code&gt;Annotation&lt;/code&gt;接口，转到接口源码。&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685627730431.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;所以注解是什么呢？接口？类？抽象类？&lt;br&gt;
看一下字节码:&lt;img src=&#34;https://silentiris.github.io/post-images/1685627740206.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现调用的是INVOKEINTERFACE指令，在jvm中方法调用的指令有如下四种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;invokestatic&lt;/code&gt;：用于调用静态方法。这个指令会根据方法的符号引用定位到目标方法，并执行方法调用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;invokespecial&lt;/code&gt;：用于调用实例构造方法（&lt;code&gt;&amp;lt;init&amp;gt;&lt;/code&gt;）、私有方法以及父类的方法（包括构造方法）。这个指令同样会根据方法的符号引用定位到目标方法，并执行方法调用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;invokevirtual&lt;/code&gt;：用于调用普通实例方法。这个指令会在运行时根据对象的实际类型找到对应的方法，并执行方法调用。如果目标方法是动态绑定的（即被重写的方法），会根据对象的实际类型来确定调用哪个版本的方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;invokeinterface&lt;/code&gt;：用于调用接口方法。与 &lt;code&gt;invokevirtual&lt;/code&gt; 类似，不同之处在于这个指令是为了调用接口中的方法。它会在运行时根据对象的实际类型找到对应的实现类，并执行方法调用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，编译器认为value()方法是一个接口方法。&lt;br&gt;
所以，我们可以得出结论：注解是一个继承自Annotation接口的接口。里面的每一个属性，其实就是接口的一个抽象方法。&lt;/p&gt;
&lt;p&gt;那么新的问题来了，如果注解是接口，那么其何时实例化，怎么实例化？&lt;br&gt;
我们是通过 AnnotationDemo.class.getDeclaredAnnotation(MyAnnotation.class);  来获取到注解的实例的，那么使用debug模式看一下这个方法。&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685627755437.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现返回的实例名称 是$Proxy1, 很明显是一个代理对象，里面还有一个叫AnnotationInvocationHandler的类。&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685627764793.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
上图就是注解的代理逻辑封装。&lt;/p&gt;
&lt;p&gt;总结：注解@interface 是一个实现了Annotation接口的接口， 然后在调用getDeclaredAnnotations()方法的时候，返回一个代理$Proxy对象，这个是使用jdk动态代理创建，使用Proxy的newProxyInstance方法，传入接口 和InvocationHandler的一个实例(也就是 AnotationInvocationHandler ) ，最后返回一个实例。&lt;/p&gt;
&lt;p&gt;那么Proxy的newProxyInstance方法在何处调用呢？我们继续步入。&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685627785449.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
sun.reflect.annotation.AnnotationParser#annotationForMap&lt;br&gt;
在这里jdk动态代理的newProxyInstance返回代理对象&lt;/p&gt;
&lt;p&gt;现在，还有一个问题：一开始传给注解的参数，存储到了哪？&lt;br&gt;
我们查看getDeclaredAnnotation这个方法的源码。&lt;img src=&#34;https://silentiris.github.io/post-images/1685627801087.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;进入 declaredAnnotations&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685627849575.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看到，这是Class.java里的一个静态内部类，declaredAnnotations是一个map，&lt;br&gt;
我们从这个map中取出注解的代理对象。&lt;/p&gt;
&lt;p&gt;cd ..&lt;br&gt;
进入 annotationData()&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685627857362.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
发现annotationData()返回了一个newAnnotationData。这个newAnnotationData是&lt;code&gt;AnnotationData newAnnotationData = createAnnotationData(classRedefinedCount);&lt;/code&gt;创造的，（while部分是缓存，只会解析一次注解）&lt;/p&gt;
&lt;p&gt;进入 createAnnotationData(classRedefinedCount)&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685627864206.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看到，这个方法return了一个&lt;code&gt;new AnnotationData(annotations, declaredAnnotations, classRedefinedCount)&lt;/code&gt;，调用&lt;code&gt;AnnotationData&lt;/code&gt;的构造函数，那么AnnotationData里的map从哪里来呢？&lt;/p&gt;
&lt;p&gt;就在这个函数的第一行。&lt;br&gt;
可以看到，&lt;code&gt;AnnotationParser.parseAnnotations(getRawAnnotations(), getConstantPool(), this);&lt;/code&gt;产生了一个所需map。&lt;br&gt;
需要注意的是其中的两个参数&lt;code&gt;getRawAnnotations()&lt;/code&gt;和&lt;code&gt;getConstantPool()&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;getRawAnnotations():&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685628419881.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
native方法，获取原始批注。&lt;/li&gt;
&lt;li&gt;getConstantPool():&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685628437075.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
获取常量池 也是native方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进入parseAnnotations方法&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685628576651.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
调用parseAnnotations2方法。&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685628615509.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;进入parseAnnotations2方法。&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685628513044.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看到map在这时被填充&lt;br&gt;
klass是键，由&lt;code&gt;a.annotationType()&lt;/code&gt;返回,annotationType()是Annotation类的一个方法，返回该注解的class对象。&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685628635090.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
值是a本身，一个Annotation对象。&lt;br&gt;
这个对象从&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685628651055.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这个函数获得。这是一个重载的函数，我们进入这个函数。&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685628686997.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;进入parseAnnotation2另一个被重载的函数。&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685628770586.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
函数很长，函数最后有一个&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685628787224.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
是不是很眼熟，进入发现&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685628801431.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
正是上面调用newProxyInstance的函数。&lt;br&gt;
再转回来看annotationForMap的入参，是注解的字节码文件和一个map，这个map在上面被填入了这个注解的全部信息。&lt;br&gt;
怎么填入的呢？&lt;br&gt;
&lt;img src=&#34;https://silentiris.github.io/post-images/1685628808933.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
value从&lt;code&gt;parseMemberValue(memberType, buf, constPool, container)&lt;/code&gt;取得。&lt;br&gt;
所以最终发现，注解的信息都放在了constpool中，在创建实例的时候，会通过getConstantPool()获取出来，是一个byte[]流，需要进行转换。&lt;/p&gt;
&lt;p&gt;通过入参的数据，annotationForMap创造了一个代理对象，并且逐级返回，被塞进了declaredAnnotations这个map中，这个map的key是注解的class对象，value是代理对象。然后通过&lt;code&gt;annotationData().declaredAnnotations.get(annotationClass)&lt;/code&gt;返回给了 &lt;code&gt; AnnotationDemo.class.getDeclaredAnnotation(MyAnnotation.class)&lt;/code&gt;，即我们在demo中调用的地方，并把返回的代理对象交给了myAnnotation。&lt;/p&gt;
&lt;p&gt;让我们做一个总结。&lt;br&gt;
注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。在调用getDeclaredAnnotations()方法的时候，返回一个代理$Proxy对象，这个对象使用jdk动态代理创建，使用Proxy的newProxyInstance方法时候，传入Annotation的class对象和InvocationHandler的一个实例(也就是AnotationInvocationHandler ) ，最后返回一个代理实例。期间，在创建代理对象之前，解析注解时候 从该注解类的常量池中取出注解的信息，包括之前写到注解中的参数，然后将这些信息在创建 AnnotationInvocationHandler时候 ，传入进去 作为构造函数的参数。&lt;br&gt;
通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。&lt;/p&gt;
&lt;p&gt;文章参考：&lt;br&gt;
注解基础部分：&lt;br&gt;
&lt;a href=&#34;https://pdai.tech/md/java/basic/java-basic-x-annotation.html&#34;&gt;https://pdai.tech/md/java/basic/java-basic-x-annotation.html&lt;/a&gt;&lt;br&gt;
注解底层实现部分：&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/qq_20009015/article/details/106038023&#34;&gt;https://blog.csdn.net/qq_20009015/article/details/106038023&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://juejin.cn/post/6960685149503619109&#34;&gt;https://juejin.cn/post/6960685149503619109&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://juejin.cn/post/6960685149503619109&#34;&gt;https://juejin.cn/post/6960685149503619109&lt;/a&gt;&lt;/p&gt;
">java注解原理</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


  <script
    src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>






</html>